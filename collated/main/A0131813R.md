# A0131813R
###### \java\seedu\lifekeeper\commons\util\DateUtil.java
``` java

    public static Date parseDateTime(String date) throws IllegalValueException {
        Date validDate;
        for (SimpleDateFormat sdf : DATE_FORMATS) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return validDate;
                }
            } catch (ParseException e) {
                continue;
            }
        }
        throw new IllegalValueException(INVALID_FORMAT);
    }

    public static boolean hasPassed(Date date) {
        Date today = Calendar.getInstance().getTime();

        if (date.before(today)) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Returns true if a given string is a valid task reminder.
     */
    public static boolean isValidDate(String test) {
        if (validate(test) || test.equals("") || test.contains("today") || test.contains("tomorrow")
                || test.contains("mon") || test.contains("tue") || test.contains("wed") || test.contains("thu")
                || test.contains("fri") || test.contains("sat") || test.contains("sun"))
            return true;
        else
            return false;
    }

    /**
     * Convert days of the week into date formats
     * 
     * @param String Date
     * @return Date in String format
     */

    public static String convertDateWhenDayOfTheWeekIsGiven(String date) throws IllegalValueException {
        Date today = new Date();
        String strDate;
        int dayIndex;
        if (date.contains("today"))
            strDate = new SimpleDateFormat("d-MM-yyyy").format(new Date());
        else if (date.contains("tomorrow")) {
            new Date(today.getTime() + TimeUnit.DAYS.toMillis(1));
            strDate = new SimpleDateFormat("d-MM-yyyy").format(today.getTime() + TimeUnit.DAYS.toMillis(1));
        } else if (date.contains("mon") || date.contains("tue") || date.contains("wed") || date.contains("thu")
                || date.contains("fri") || date.contains("sat") || date.contains("sun")) {
            dayIndex = findDayOfTheWeek(date);
            strDate = new SimpleDateFormat("d-MM-yyyy").format(today.getTime() + TimeUnit.DAYS.toMillis(dayIndex));
        } else
            throw new IllegalValueException(INVALID_FORMAT);
        return concatDateTime(strDate, date);

    }
    /**
     * @return String that concatenate time with date.
     */
    private static String concatDateTime(String strDate, String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        String part2 = strDate;
        if (timeparts.length != 1) {
            part2 = timeparts[1];
            if (timeparts.length == 3) {
                String part3 = timeparts[2];
                part2 = part2.concat(" " + part3);
            }
            part2 = strDate.concat(" " + part2);
        } else
            throw new IllegalValueException(INVALID_TIME);
        return part2;
    }

    public static int findDayOfTheWeek(String date) {
        int dayindex = 0;
        int diff = 0;
        int today = Calendar.getInstance().get(Calendar.DAY_OF_WEEK);
        if (date.contains("mon"))
            dayindex = Calendar.MONDAY;
        else if (date.contains("tue"))
            dayindex = Calendar.TUESDAY;
        else if (date.contains("wed"))
            dayindex = Calendar.WEDNESDAY;
        else if (date.contains("thu"))
            dayindex = Calendar.THURSDAY;
        else if (date.contains("fri"))
            dayindex = Calendar.FRIDAY;
        else if (date.contains("sat"))
            dayindex = Calendar.SATURDAY;
        else if (date.contains("sun"))
            dayindex = Calendar.SUNDAY;
        diff = (today >= dayindex) ? (7 - (today - dayindex)) : (dayindex - today);
        if (diff == 7)
            diff = 0;
        return diff;
    }

    public static Date convertDueDate(String date) throws IllegalValueException {
        if (date.split(" ").length == 1) {
            date = date.concat(" 2359");
        }
        if (date.contains("today") || date.contains("tomorrow") || date.contains("mon") || date.contains("tue")
                || date.contains("wed") || date.contains("thu") || date.contains("fri") || date.contains("sat")
                || date.contains("sun")) { // allow user to key in "today"
                                           // instead of today's date
            date = convertDateWhenDayOfTheWeekIsGiven(date);
        }
        Date taskDate = parseDateTime(date);
        return taskDate;
    }

    public static Date convertDate(String date) throws IllegalValueException {
        if (date.contains("today") || date.contains("tomorrow") || date.contains("mon") || date.contains("tue")
                || date.contains("wed") || date.contains("thu") || date.contains("fri") || date.contains("sat")
                || date.contains("sun")) { // allow user to key in "today"
                                           // instead of today's date
            date = convertDateWhenDayOfTheWeekIsGiven(date);
        }
        Date taskDate = parseDateTime(date);
        return taskDate;
    }

    public static Calendar EndDateTime(Date date) throws IllegalValueException {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.add(Calendar.HOUR_OF_DAY, 1);
        return cal;

    }

    // these following methods used only for testing purposes only.

    /**
     * Convert a given calendar object into a string format
     * 
     * @param string
     *            ""
     * @return tomorrow in valid date format
     */

    public String outputDateTimeAsString(Calendar dateTime, String format) {
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.format(dateTime.getTime());
    }

```
###### \java\seedu\lifekeeper\commons\util\DateUtil.java
``` java
    /**
     * Set date based on the date passed in
     * 
     * @param String
     * @return Calendar date
     */
    public static Calendar setDate(String date) throws IllegalValueException {
        String[] recur = date.split(" ", 2);
        String recurfreq = recur[0];

        if (recur.length != 1) {

            if (recurfreq.contains("day")) {
                date = "today " + recur[1];
            }

            if (!date.equals("")) {
                Date taskDate = DateUtil.convertDate(date);
                if (!DateUtil.isValidDate(date)) {
                    throw new IllegalValueException(INVALID_FORMAT);
                }
                if (taskDate == null) {
                    assert false : "Date should not be null";
                }
                Calendar cal = Calendar.getInstance();
                cal.setTime(taskDate);
                cal.set(Calendar.MILLISECOND, 0);
                cal.set(Calendar.SECOND, 0);

                return cal;
            }

        }
        if (date.equals(""))
            return null;
        throw new IllegalValueException(INVALID_FORMAT);
    }
}
```
###### \java\seedu\lifekeeper\logic\commands\AddCommand.java
``` java
    public AddCommand(String name, String duedate, String priority, String start, String end, String reminder,
            Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        String type = identifyActivityType(duedate, priority, start, end);

        if (type == "task") {

            this.toAdd = new Task(new Name(name), new DueDate(duedate), new Priority(priority), new Reminder(reminder),
                    new UniqueTagList(tagSet));
            if (duedate.length() > 0)
                if (((Task) toAdd).getDueDate().value.before(Calendar.getInstance())) {
                    throw new IllegalValueException(DueDate.MESSAGE_DUEDATE_INVALID);
                }
        } else if (type == "event") {
            this.toAdd = new Event(new Name(name), new StartTime(start), new EndTime(new StartTime(start), end),
                    new Reminder(reminder), new UniqueTagList(tagSet));
            if(((Event)toAdd).getStartTime().value.before(Calendar.getInstance())){
                throw new IllegalValueException(StartTime.MESSAGE_STARTTIME_INVALID);
            }
        } else if (type == "float") {

            this.toAdd = new Activity(new Name(name), new Reminder(reminder), new UniqueTagList(tagSet));
        } else {
            assert false;
            throw new IllegalValueException(MESSAGE_INVALID_ACTIVITY_TYPE);
        }
        if(reminder.length()>0)
            if(this.toAdd.getReminder().value.before(Calendar.getInstance()))
                    throw new IllegalValueException(Reminder.MESSAGE_REMINDER_INVALID);

    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);

            PreviousCommand addCommand = new PreviousCommand(COMMAND_WORD, toAdd);
            PreviousCommandsStack.push(addCommand);

            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueActivityList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### \java\seedu\lifekeeper\logic\commands\ListCommand.java
``` java
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    
    private final String typeOfList;

    public static final String MESSAGE_SUCCESS = "Listed all undone";
    
    public static final String MESSAGE_SUCCESS_ALL = "Listed all";
    
    public static final String MESSAGE_SUCCESS_TASK = "Listed tasks only";

    public static final String MESSAGE_SUCCESS_ACT = "Listed activities only";
    
    public static final String MESSAGE_SUCCESS_EVENT = "Listed events only";
    
    public static final String MESSAGE_SUCCESS_DONE = "Listed completed events and tasks only";
    
    public static final String MESSAGE_INVALID_LIST_TYPE = "List Command should be followed by (optional) 'all', 'done', 'activity', 'event' or 'task' only ";   
    
    public ListCommand(String typeOfList) {
        this.typeOfList= typeOfList;
    }

    @Override
    public CommandResult execute() {

      switch(typeOfList) {

      case "activity":   
          model.updateFilteredActivityListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_ACT);
      
      case "task":
    	  model.updateFilteredTaskListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_TASK);
      
      case "event":
          model.updateFilteredEventListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_EVENT);

      case "done":
          model.updateFilteredDoneListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_DONE);
          
      case "all":
          model.updateAllListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_ALL);
          
          default: //typeOfList equals ""
			model.updateFilteredListToShowAll();
			return new CommandResult(MESSAGE_SUCCESS);
		}
      
      }
    	
}
```
###### \java\seedu\lifekeeper\model\activity\Activity.java
``` java
public class Activity implements ReadOnlyActivity {

    protected Name name;
    protected Reminder reminder;
    protected boolean isCompleted;
    protected UniqueTagList tags;

    /**
     * Every field must be present and not null.
     */
    public Activity(Name name, Reminder reminder, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, reminder, tags);
        this.name = name;
        this.reminder = reminder;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }

    /**
     * Copy constructor.
     */
    public Activity(ReadOnlyActivity source) {
        this(source.getName(), source.getReminder(), source.getTags());
        this.isCompleted =  source.getCompletionStatus();
    }

    @Override
    public Name getName() {
        return name;
    }
    
    public void setName(Name name) {
        this.name = name;
    }

    @Override
    public Reminder getReminder() {
        return reminder;
    }
    
    public void setReminder(Reminder reminder) {
        this.reminder = reminder;
    }
    
    @Override
    public boolean getCompletionStatus() {
        return isCompleted;
    }
    
    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
```
###### \java\seedu\lifekeeper\model\activity\event\EndTime.java
``` java
public class EndTime extends DateTime {

    public static final String MESSAGE_ENDTIME_CONSTRAINTS = "Event's end time should only contain valid date";
    public static final String MESSAGE_ENDTIME_INVALID = "Event has already ended";
    public static final String MESSAGE_ENDTIME_NOTVALID = "Event end time is before start time";
    public String RecurringMessage;

    public EndTime(Calendar date) {
        super(date);
    }

    /**
     * Validates given Start Time 
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    public EndTime(StartTime starttime, String date) throws IllegalValueException {
        super(Calendar.getInstance());
        SimpleDateFormat start = new SimpleDateFormat("d-MM-yyyy HH:mm");
        String startstring = start.format(starttime.value.getTime());
        Date startdate;
        try {
            startdate = start.parse(startstring);
        } catch (ParseException e) {
            throw new IllegalValueException("Start Time Invalid");
        }
        formEndTimeDateString(starttime, date, startdate, startstring);
    }
    
    
    /**
     * Validates given Start Time and 
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    private void formEndTimeDateString(StartTime starttime, String date, Date startdate, String startstring) throws IllegalValueException{
        if (starttime.recurring) {
            if (date.equals("")) {
                checkRecurring(starttime, date, startdate);
            } else {
                recurringEndTime(starttime, startdate, date);
            }
        } else if (date.equals("")) {
            this.value = DateUtil.EndDateTime(startdate);
        } else if (date.split(" ").length == 1) {
            String[] startt = startstring.split(" ");
            date = startt[0] + " " + date;
            this.value = DateUtil.setDate(date);
        } else {
            if (!DateUtil.isValidDate(date)) {
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            }
            this.value = DateUtil.setDate(date);
        }
        checkForBeforeStartTime(starttime, date);
    }

    private void checkForBeforeStartTime(StartTime starttime, String date) throws IllegalValueException {
        if (this.value.before(starttime.value)) {
            while (this.value.before(starttime.value)) {
                if ((date.contains("mon") || date.contains("tue") || date.contains("wed") || date.contains("thu")
                        || date.contains("fri") || date.contains("sat") || date.contains("sun")))
                    this.value.add(Calendar.DAY_OF_WEEK, 7);
                else if ((date.contains("day")) && recurring)
                    this.value.add(Calendar.DAY_OF_MONTH, 1);
                throw new IllegalValueException(MESSAGE_ENDTIME_NOTVALID);
            }
        }
    }

    public EndTime(Calendar date, boolean isRecurring, String recurringMessage) {
        super(date);
        this.recurring = isRecurring;
        this.RecurringMessage = recurringMessage;
    }

    /**
     * HandleRecurringTask if the endtime is not entered, set to default
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    private void checkRecurring(StartTime starttime, String date, Date startdate) throws IllegalValueException {
        recurring = true;
        String recu[] = starttime.RecurringMessage.split(" ");
        Calendar startcal = starttime.value;
        startcal.add(Calendar.HOUR_OF_DAY, 1);
        SimpleDateFormat format1 = new SimpleDateFormat("EEE HHmm");
        RecurringMessage = recu[0] + " " + format1.format(startcal.getTime());
        this.value = DateUtil.EndDateTime(startdate);
    }

    /**
     * HandleRecurringTask if the endtime is enter, handle different variations
     * of endtime
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    private void recurringEndTime(StartTime starttime, Date startdate, String date) throws IllegalValueException {
        this.recurring = true;
        String[] recur;
        recur = date.split(" ");
        String[] recurstart;
        recurstart = starttime.RecurringMessage.split(" ");
        String[] recurendtime;
        if (recur.length == 1) {
            RecurringMessage = recurstart[0] + " " + recurstart[1] + " " + recur[0];
            date = recurstart[1] + " " + recur[0];
        } else if (date.contains("every")) {
            RecurringMessage = date;
            recurendtime = date.split(" ", 2);
            if (recurendtime.length == 1)
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            date = recurendtime[1];
        } else if (recur.length == 2) {
            RecurringMessage = "every " + date;
        } else
            throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
        if (!DateUtil.isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
        }
        this.value = DateUtil.setDate(date);

        Calendar cal = Calendar.getInstance();
        cal.setTime(startdate);
    }

    public EndTime(String date) throws IllegalValueException {
        super(date);
        String[] recur;
        if (date != "") {
            if (date.contains("every")) {
                this.recurring = true;
                RecurringMessage = date;
                recur = date.split(" ", 2);
                if (recur.length == 1)
                    throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
                date = recur[1];
            }
            if (!DateUtil.isValidDate(date)) {
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            }
            this.value = DateUtil.setDate(date);
        }
    }
}
```
###### \java\seedu\lifekeeper\model\activity\event\Event.java
``` java
public class Event extends Activity implements ReadOnlyEvent{

    private static final int DAYS_WARNING = -3;
	private StartTime startTime;
    private EndTime endTime;
    
    public Event(Name name, StartTime start, EndTime end, Reminder reminder, UniqueTagList tags) {
        super(name, reminder, tags);
        
//        assert !CollectionUtil.isAnyNull(start, end);
        this.startTime = start;
        this.endTime = end;
    }
    
    /**
     * Copy constructor.
     */
    public Event(ReadOnlyEvent source) {
        this(source.getName(), source.getStartTime(), source.getEndTime(), source.getReminder(), source.getTags());
        this.isCompleted =  source.getCompletionStatus();
    }
    
    @Override
    public StartTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(StartTime starttime) {
        this.startTime= starttime;
    }
    
    @Override
    public EndTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(EndTime endtime) {
        this.endTime= endtime;
    }
    
    /**
     * Checks if this event is currently ongoing.
     * @return true if the current time is between the start and end time.
     */
    @Override
    public boolean isOngoing() {
        return startTime.isBeforeNow() && endTime.isAfterNow();
    }

    /**
     * Checks if this event is over. Returns false for recurring tasks.
     * @return true if the current time is after the end time.
     */
    @Override
    public boolean isOver() {
        if (this.startTime.recurring) {
            checkrecurring();
            return false;
        }
        
        this.isCompleted = endTime.isBeforeNow();
        return this.isCompleted;
    }
    
    @Override
    public boolean getisOver() {
        return isOver();
    }

    /**
     * @return String indicating the status of the event, either its ongoing or its over.
     */
    @Override
    public String toStringCompletionStatus() {
        if(this.isOver()) {
            return "Event\nOver";
        } else if (this.isOngoing()) {
            return "Event\nOngoing";
        } else {
            return "";
        }
    }
    /**
     * @return String that displays visually clear date format for user to read
     */
    @Override
    public String displayTiming() {
        String message = "";
        SimpleDateFormat sdf;

        if (this.getStartTime().recurring) {
            checkrecurring();
            message = message.concat("Every ");
            sdf = new SimpleDateFormat("EEEE, h:mm aa");
        } else {
            message = message.concat("From ");
            sdf = new SimpleDateFormat("EEE, MMM d, yyyy h:mm a");
        }

        if (isStartAndEndOnSameDate()) {
            SimpleDateFormat timeOnly = new SimpleDateFormat("h:mm aa");
            message = message.concat(sdf.format(startTime.getCalendarValue().getTime()) + " to "
                    + timeOnly.format(endTime.getCalendarValue().getTime()));
        } else {
            message = message.concat(sdf.format(startTime.getCalendarValue().getTime()) + " to "
                    + sdf.format(endTime.getCalendarValue().getTime()));
        }
        return message;
    }
    /**
     * Check if the recurring event is over, so that the Start and end time will be updated to the next instance when the event should occur
     */
    private void checkrecurring() {
        if (this.getEndTime().value.before(Calendar.getInstance())) {
            if (this.getStartTime().RecurringMessage.contains("sun")
                    || this.getStartTime().RecurringMessage.contains("mon")
                    || this.getStartTime().RecurringMessage.contains("tue")
                    || this.getStartTime().RecurringMessage.contains("wed")
                    || this.getStartTime().RecurringMessage.contains("thu")
                    || this.getStartTime().RecurringMessage.contains("fri")
                    || this.getStartTime().RecurringMessage.contains("sat")) {
                this.getStartTime().value.add(Calendar.DAY_OF_WEEK, 7);
                this.getEndTime().value.add(Calendar.DAY_OF_WEEK, 7);
            } else {
                this.getEndTime().value.add(Calendar.DAY_OF_MONTH, 1);
                this.getStartTime().value.add(Calendar.DAY_OF_MONTH, 1);
            }
        }

    }

    private boolean isStartAndEndOnSameDate() {
        return startTime.getCalendarValue().get(Calendar.YEAR) == endTime.getCalendarValue().get(Calendar.YEAR)
                && startTime.getCalendarValue().get(Calendar.DAY_OF_YEAR) == endTime.getCalendarValue()
                        .get(Calendar.DAY_OF_YEAR);
    }

    @Override
    public boolean equals(Object other) {
        if (this == null || other == null) {
            return !(this == null ^ other == null);
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            return other == this // short circuit if same object
                    || (other instanceof ReadOnlyActivity // instanceof handles nulls
                    && ((Event) other).getName().equals(this.getName()) // state checks here onwards
                    && ((Event) other).getStartTime().equals(this.getStartTime())
                    && ((Event) other).getEndTime().equals(this.getEndTime())
                    && ((Event) other).getReminder().equals(this.getReminder()));
        }
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, startTime, endTime, reminder, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
    
    /**
     * Checks if the start time is approaching and returns true if so.
     * @return true if the current time is a certain number of days before the due date (default 3).
     */
    public boolean isStartTimeApproaching() {
        if(startTime.getCalendarValue() == null) {
            return false;           
        } else {
            Calendar cal = Calendar.getInstance();
            Date now = cal.getTime();
            cal.setTime(startTime.getCalendarValue().getTime());
            cal.add(Calendar.DAY_OF_MONTH, DAYS_WARNING);
            Date warningDate = cal.getTime();
            return warningDate.before(now)
                    && startTime.getCalendarValue().getTime().after(now);       
        }
    }
    /**
     * Checks whether Event fulfills the criteria for being an upcoming event to be displayed on Upcoming Dashboard.
     * @return true if Event is not Ongoing, not Over, and will start within (default 3) days of from today.
     */
    public boolean isUpcoming() {
    	if (this.isOngoing()) {
    		return false;
    	}
    	
    	if (this.isOver()) {
    		return false;
    	}
    	
    	if (this.isStartTimeApproaching()) {
    		return true;
    	} else {
    		return false;
    	}
    }
    
}
```
###### \java\seedu\lifekeeper\model\activity\event\StartTime.java
``` java
public class StartTime extends DateTime {

    public static final String MESSAGE_STARTTIME_CONSTRAINTS = "Event's start time should only contain valid date";
    public static final String MESSAGE_STARTTIME_INVALID = "Event has already started";
    public String RecurringMessage;

    public StartTime(Calendar date) {
        super(date);
    }

    /**
     * Validates given Start Time.
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    public StartTime(String date) throws IllegalValueException {
        super(date);
        String[] recur;
        if (date != "") {
            if (date.contains("every")) {
                this.recurring = true;
                RecurringMessage = date;
                recur = date.split(" ", 2);
                if (recur.length == 1)
                    throw new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS);
                date = recur[1];
            }
            this.value= DateUtil.setDate(date);
            if(recurring && this.value.before(Calendar.getInstance()))
                this.value.add(Calendar.DAY_OF_MONTH, 7);
        }

    }
    
    public StartTime(Calendar date, boolean isRecurring, String recurringMessage) {
        super(date);
        this.recurring = isRecurring;
        this.RecurringMessage = recurringMessage;
    }
}
```
###### \java\seedu\lifekeeper\model\activity\Reminder.java
``` java
public class Reminder extends DateTime {

    public static final String MESSAGE_REMINDER_CONSTRAINTS = "Task reminder can only be in date format";
    public static final String MESSAGE_REMINDER_INVALID = "reminder time has passed";
    public String recurringMessage;

    public Reminder(Calendar date) {
        super(date);
    }

    /**
     * Validates given reminder.
     *
     * @throws IllegalValueException
     *             if given reminder string is invalid.
     */
    public Reminder(String date) throws IllegalValueException {
        super(date);
        String[] recur;
        if (date != "") {
            if (date.contains("every")) {
                this.recurring = true;
                recurringMessage = date;
                recur = date.split(" ", 2);
                if (recur.length == 1)
                    throw new IllegalValueException(MESSAGE_REMINDER_CONSTRAINTS);
                date = recur[1];
            }
            if (!DateUtil.isValidDate(date)) {
                throw new IllegalValueException(MESSAGE_REMINDER_CONSTRAINTS);
            }
                this.value = DateUtil.setDate(date);
                if(recurring && this.value.before(Calendar.getInstance()))
                    this.value.add(Calendar.DAY_OF_MONTH, 7);
        }
    }

    /**
     * Advances the reminder by a week (7 days) if it is recurring.
     */
    public void resetTime() {
        if (this.recurring) {
            this.value.add(Calendar.DAY_OF_MONTH, 7);
        }
    }

    public String forDisplay() {
        if (this.value == null) {
            return "Reminder:\t-";
        } else {
            if (!recurring) {
                return "Reminder:\t".concat(this.toString());
            } else {
                SimpleDateFormat sdfRecurr = new SimpleDateFormat("EEEE, h:mm aa");
                return "Reminder:\t".concat("Every " + sdfRecurr.format(this.value.getTime()));
            }
        }
    }

}
```
###### \java\seedu\lifekeeper\model\activity\task\DueDate.java
``` java
/**
 * Represents a Task's DueDate in the Lifekeeper. Guarantees: immutable; is
 * valid as declared in {@link #isValidDueDate(String)}
 */
public class DueDate extends DateTime {

    public static final String MESSAGE_DUEDATE_CONSTRAINTS = "Task's DueDate should only contain valid date";
    public static final String MESSAGE_DUEDATE_INVALID = "Deadline is over";
    protected static final SimpleDateFormat DASHBOARD_DATE_FORMATTER = new SimpleDateFormat("EEE, MMM d");

    public DueDate(Calendar date) {
        super(date);
    }

    /**
     * Validates given Due Date.
     *
     * @throws IllegalValueException
     *             if given due date string is invalid.
     */
    public DueDate(String date) throws IllegalValueException {
        super(date);
        if (!DateUtil.isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_DUEDATE_CONSTRAINTS);
        }

        if (!date.equals("")) {

            Date taskDate = DateUtil.convertDueDate(date);

            if (taskDate == null) {
                assert false : "Date should not be null";
            }
            this.value.setTime(taskDate);
            this.value.set(Calendar.MILLISECOND, 0);
            this.value.set(Calendar.SECOND, 0);
        }
    }

    public String forDisplay() {
        if (this.value == null) {
            return "";
        } else {
            return "Due on ".concat(this.toString());
        }
    }

    /**
     * Function to output date in concise form for Dashboard.
     * 
     * @return
     */
    // @@ author A0125284H
    public String forDashboardDisplay() {
        if (this.value == null) {
            return "";
        } else {
            return (DASHBOARD_DATE_FORMATTER.format(this.getCalendarValue().getTime()));
        }
    }
}
```
###### \java\seedu\lifekeeper\model\activity\task\Task.java
``` java
public class Task extends Activity implements ReadOnlyTask {

    private DueDate duedate;
    private Priority priority;
    
    private static int DAYS_WARNING = -3;
    
    /**
     * Every field must be present and not null.
     */
    public Task(Name name, DueDate dueDate, Priority priority, Reminder reminder, UniqueTagList tags) {
        super(name, reminder, tags);
        
//        assert !CollectionUtil.isAnyNull(dueDate, priority);
        this.duedate = dueDate;
        this.priority = priority;
        this.isCompleted = false;
    }
    
    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDueDate(), source.getPriority(), source.getReminder(), source.getTags());
        this.isCompleted =  source.getCompletionStatus();
    }
    
    @Override
    public DueDate getDueDate() {
        return duedate;
    }
    
    public void setDueDate(DueDate duedate) {
        this.duedate = duedate;
    }
    
    @Override
    public Priority getPriority() {
        return priority;
    }
    
    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    @Override
    public boolean getCompletionStatus() {
        return isCompleted;
    }
    
    public void setCompletionStatus(boolean isComplete) {
        this.isCompleted = isComplete;
    }
    
    @Override
    public String toStringCompletionStatus() {
        if(isCompleted) {
            return "Completed";
        } else if (!isCompleted && this.isDueDateApproaching()) {
            return "Task Deadline Approaching";
        } else if(!isCompleted && this.hasPassedDueDate()){
            return "Task\nOverdue!";
        }
        
        return "";  
    }
    
    /**
     * Checks if the due date is approaching and returns true if so.
     * @return true if the current time is a certain number of days before the due date (default 3).
     */
    @Override
    public boolean isDueDateApproaching() {
        if(duedate.getCalendarValue() == null) {
            return false;           
        } else {
            Calendar cal = Calendar.getInstance();
            Date now = cal.getTime();
            cal.setTime(duedate.getCalendarValue().getTime());
            cal.add(Calendar.DAY_OF_MONTH, DAYS_WARNING);
            Date warningDate = cal.getTime();
            return warningDate.before(now)
                    && duedate.getCalendarValue().getTime().after(now);       
        }
    }
    
    /**
     * Returns true if the task is overdue.
     * @return true if the current time is after the task's due date.
     */
    @Override
    public boolean hasPassedDueDate() {
        if(duedate.getCalendarValue() == null) {
        	return false;        	
        } else {
            return duedate.isBeforeNow();     
        }
    }

    
    @Override
    public boolean equals(Object other) {
        if (this == null || other == null) {
            return !(this == null ^ other == null);
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            return other == this // short circuit if same object
                    || (other instanceof ReadOnlyActivity // instanceof handles nulls
                    && ((Task) other).getName().equals(this.getName()) // state checks here onwards
                    && ((Task) other).getDueDate().equals(this.getDueDate())
                    && ((Task) other).getPriority().equals(this.getPriority())
                    && ((Task) other).getReminder().equals(this.getReminder()));
        }
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, duedate, priority, reminder, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
}
```
###### \java\seedu\lifekeeper\model\Model.java
``` java
    void updateFilteredEventListToShowAll();

    void updateFilteredActivityListToShowAll();

    void updateFilteredTaskListToShowAll();

    void updateFilteredByTagListToShowAll(String tag);

    void updateFilteredDoneListToShowAll();

    void updateAllListToShowAll();


    
}
```
###### \java\seedu\lifekeeper\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredActivities.setPredicate(p->
        p.getCompletionStatus() == false && p.getisOver() == false);
  		FilteredList<Activity> filteredList = new FilteredList<>(lifeKeeper.getAllEntries());
  		
  		filteredList.setPredicate(p->
  		p.getClass().getSimpleName().equalsIgnoreCase("Task")
  		 && (p.getCompletionStatus() == false && p.hasPassedDueDate() == true));
  		
  		
  		return;
  	}
  	
    
    @Override
    public void updateFilteredByTagListToShowAll(String tag) {
        filteredActivities.setPredicate(p->
        p.getTags().contains(tag));
    }
    
    @Override
    public void updateFilteredTaskListToShowAll() {
        filteredActivities.setPredicate(p->
        p.getClass().getSimpleName().equalsIgnoreCase("Task"));
    }
    
    @Override
    public void updateFilteredDoneListToShowAll() {
        filteredActivities.setPredicate(p->
        p.getCompletionStatus() == true || p.getisOver() == true);
    }
    
    @Override
    public void updateFilteredActivityListToShowAll() {
        filteredActivities.setPredicate(p->
        p.getClass().getSimpleName().equalsIgnoreCase("Activity"));
    }
    
    @Override
    public void updateAllListToShowAll() {
        filteredActivities.setPredicate(null);
    }
    
    @Override
    public void updateFilteredEventListToShowAll() {
        filteredActivities.setPredicate(p->
        p.getClass().getSimpleName().equalsIgnoreCase("Event"));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords){
        updateFilteredActivityList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredActivityList(Expression expression) {
        filteredActivities.setPredicate(expression::satisfies);
    }
   
    
        
```
###### \java\seedu\lifekeeper\storage\XmlAdaptedActivity.java
``` java
        case "event":
            type = "event";
            line1 = ((ReadOnlyEvent) source).getStartTime().toSave();
            line2 = ((ReadOnlyEvent) source).getEndTime().toSave();
            if (((ReadOnlyEvent) source).getStartTime().value != null) {
                if (((ReadOnlyEvent) source).getStartTime().recurring)
                    recurring = true;
                else
                    recurring = false;
            }
            if (((ReadOnlyEvent) source).getStartTime() != null
                    && ((ReadOnlyEvent) source).getStartTime().RecurringMessage!=null)
                starttimeRecurring = ((ReadOnlyEvent) source).getStartTime().RecurringMessage;
            if (((ReadOnlyEvent) source).getEndTime() != null)
                    if(((ReadOnlyEvent) source).getEndTime().RecurringMessage!=null)
                endtimeRecurring = ((ReadOnlyEvent) source).getEndTime().RecurringMessage;
            break;

        }
    }

     /**
     * Converts this jaxb-friendly adapted Activity object into the model's
     * Activity object.
     *
     * @throws IllegalValueException
     *             if there were any data constraints violated in the adapted
     *             activity
     */
```
###### \java\seedu\lifekeeper\storage\XmlAdaptedActivity.java
``` java
    public Activity toModelType() throws IllegalValueException {
        final List<Tag> activityTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            activityTags.add(tag.toModelType());
        }

        final Name name = new Name(this.name);
        final Reminder reminder = new Reminder(this.reminder);
        reminder.recurring= this.recurring;
        reminder.recurringMessage=this.reminderRecurring;
        final UniqueTagList tags = new UniqueTagList(activityTags);

        switch (this.type) {

        case "activity":
            Activity act= new Activity(name, reminder, tags);
            act.setCompletionStatus(this.completion);
            return act;

        case "task":
            final DueDate duedate = new DueDate(this.line1);
            final Priority priority = new Priority(this.line2);
            // How to use Image to set priority?

            Task task = new Task(name, duedate, priority, reminder, tags);
            task.setCompletionStatus(this.completion);
            return task;
            
        case "event":

            final StartTime start = new StartTime(this.line1);
            start.recurring=this.recurring;
            start.RecurringMessage= this.starttimeRecurring;
            final EndTime end = new EndTime(this.line2);
            end.recurring = this.recurring;
            end.RecurringMessage = this.endtimeRecurring;
            return new Event(name, start, end, reminder, tags);

        }
        return null;

    }
}
```
