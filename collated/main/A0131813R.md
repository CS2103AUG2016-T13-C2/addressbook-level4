# A0131813R
###### \java\seedu\address\commons\util\DateUtil.java
``` java

    public static Date parseDateTime(String date) throws IllegalValueException {
        Date validDate;
        for (SimpleDateFormat sdf : DATE_FORMATS) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return validDate;
                }
            } catch (ParseException e) {
                continue;
            }
        }
        throw new IllegalValueException(INVALID_FORMAT);
    }

    public static boolean hasPassed(Date date) {
        Date today = Calendar.getInstance().getTime();

        if (date.before(today)) {
            return true;
        } else {
            return false;
        }
    }

    public static boolean isValidDate(String test) {
        if (validate(test) || test == "")
            return true;
        else
            return false;
    }

    /**
     * Convert today's date into date format Must contain time of the day in
     * hour and mins
     * 
     * @param string
     *            "tomorrow"
     * @return tomorrow in valid date format
     */

    public static String FixedTime(String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        Date today = new Date();
        String strDate;
        int dayIndex;
        if (date.contains("today"))
            strDate = new SimpleDateFormat("d-MM-yyyy").format(new Date());
        else if (date.contains("tomorrow")) {
            new Date(today.getTime() + TimeUnit.DAYS.toMillis(1));
            strDate = new SimpleDateFormat("d-MM-yyyy").format(today.getTime() + TimeUnit.DAYS.toMillis(1));
        } else if (date.contains("mon") || date.contains("tue") || date.contains("wed") || date.contains("thu")
                || date.contains("fri") || date.contains("sat") || date.contains("sun")) {
            dayIndex = DayOfTheWeek(date);
            strDate = new SimpleDateFormat("d-MM-yyyy").format(today.getTime() + TimeUnit.DAYS.toMillis(dayIndex));
        } else
            throw new IllegalValueException(INVALID_FORMAT);
        return ConcatDateTime(strDate, date);

    }

    private static String ConcatDateTime(String strDate, String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        String part1 = strDate;
        String part2 = strDate;
        if (timeparts.length != 1) {
            part2 = timeparts[1];
            if (timeparts.length == 3) {
                String part3 = timeparts[2];
                part2 = part2.concat(" " + part3);
            }
            part2 = strDate.concat(" " + part2);
        } else
            throw new IllegalValueException(INVALID_TIME);
        return part2;
    }

    public static int DayOfTheWeek(String date) {
        int dayindex = 0;
        int diff = 0;
        int today = Calendar.getInstance().get(Calendar.DAY_OF_WEEK);
        if (date.contains("mon"))
            dayindex = Calendar.MONDAY;
        else if (date.contains("tue"))
            dayindex = Calendar.TUESDAY;
        else if (date.contains("wed"))
            dayindex = Calendar.WEDNESDAY;
        else if (date.contains("thu"))
            dayindex = Calendar.THURSDAY;
        else if (date.contains("fri"))
            dayindex = Calendar.FRIDAY;
        else if (date.contains("sat"))
            dayindex = Calendar.SATURDAY;
        else if (date.contains("sun"))
            dayindex = Calendar.SUNDAY;
        return diff = (today > dayindex) ? (7 - (today - dayindex)) : (dayindex - today);
    }

    public static Date DueDateConvert(String date) throws IllegalValueException {
        if (date.split(" ").length == 1) {
            date = date.concat(" 2359");
        }
        if (date.contains("today") || date.contains("tomorrow") || date.contains("mon") || date.contains("tue")
                || date.contains("wed") || date.contains("thu") || date.contains("fri") || date.contains("sat")
                || date.contains("sun")) { // allow user to key in "today"
                                           // instead of today's date
            date = FixedTime(date);
        }
        Date taskDate = parseDateTime(date);
        return taskDate;
    }

    public static Date FixedDateConvert(String date) throws IllegalValueException {
        if (date.contains("today") || date.contains("tomorrow") || date.contains("mon") || date.contains("tue")
                || date.contains("wed") || date.contains("thu") || date.contains("fri") || date.contains("sat")
                || date.contains("sun")) { // allow user to key in "today"
                                           // instead of today's date
            date = FixedTime(date);
        }
        Date taskDate = parseDateTime(date);
        return taskDate;
    }

    public static Calendar EndDateTime(Date date) throws IllegalValueException {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.add(Calendar.HOUR_OF_DAY, 1);
        return cal;

    }

    // these following methods used only for testing purposes only.

    /**
     * Convert a given calendar object into a string format
     * 
     * @param string
     *            ""
     * @return tomorrow in valid date format
     */

    public String outputDateTimeAsString(Calendar dateTime, String format) {
        assert (isValidFormat(format));

        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.format(dateTime.getTime());
    }

```
###### \java\seedu\address\commons\util\DateValidation.java
``` java
public class DateValidation {

//    public static final String DATE_VALIDATION_REGEX = "(0?[1-9]|[12][0-9]|3[01])-(0?[1-9]|1[012])-((19|20)\\d\\d) ([01]?[0-9]|2[0-3]):([0-5][0-9])";
    public static final String INVALID_FORMAT = "Invalid Format";
    
    public void DateValidator() {

    }

    /**
     * Validate date format with regular expression
     * 
     * @param date
     * @return true valid date format, false invalid date format
     */
 /*   public static boolean validate(String date) {

        pattern = Pattern.compile(DATE_VALIDATION_REGEX);
        matcher = pattern.matcher(date);

        if (matcher.matches()) {

            matcher.reset();

            if (matcher.find()) {

                String day = matcher.group(1);
                String month = matcher.group(2);
                int year = Integer.parseInt(matcher.group(3));
                int hour = Integer.parseInt(matcher.group(4));
                int min = Integer.parseInt(matcher.group(5));
                
                if((hour<24) && (min<60)){

                if (day.equals("31") && ((month.equals("4") || month.equals("6") || month.equals("9")
                        || month.equals("11") || month.equals("04") || month.equals("06") || month.equals("09")))) {
                    return false; // 4,6,9,11th month only have 30 days
                } else if (month.equals("2") || month.equals("02")) {
                    // leap year
                    if ((year % 4 == 0) && (year % 400 == 0) && (year % 100 != 0)) {
                        if (day.equals("30") || day.equals("31")) {
                            return false;
                        } else {
                            return true;
                        }
                    } else {
                        if (day.equals("29") || day.equals("30") || day.equals("31")) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                } else {
                    return true;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }}
        return false;
    }

    // Return today's date
    public static String TodayDate() {
        String todaydate;
        todaydate = DateFormatToday();
        return todaydate;
    }

    // Return tomorrow's date
    public static String TomorrowDate() {
        String tomorrowdate;
        tomorrowdate = DateFormatTomorrow();
        return tomorrowdate;
    }
    
    //format today's date into date format dd-MM-yyyy
    public static String DateFormatToday() {
        String strDate = new SimpleDateFormat("dd-MM-yyyy").format(new Date());
        return strDate;
    }
    
    //format tomorrow's date into date format dd-MM-yyyy
    public static String DateFormatTomorrow() {
        Date today = new Date();
        Date dayafter = new Date(today.getTime() + TimeUnit.DAYS.toMillis( 1 ));
        String strDate = new SimpleDateFormat("dd-MM-yyyy").format(dayafter);
        
        return strDate;
        
    }
    //check if the time entered is not in the past
    public static boolean aftertoday (String reminderdate) throws ParseException{
        DateFormat format = new SimpleDateFormat("dd-MM-yyyy hh:mm");
        Date date = format.parse(reminderdate);
        Date today = new Date();
        if(date.before(today))
                return false;
        return true;
            
    }

    /*
     * public static boolean validate(String date) {
     * 
     * pattern = Pattern.compile(DATE_VALIDATION_REGEX); matcher =
     * pattern.matcher(date);
     * 
     * if (matcher.matches()) {
     * 
     * matcher.reset();
     * 
     * if (matcher.find()) {
     * 
     * String day = matcher.group(1); String month = matcher.group(2); int year
     * = Integer.parseInt(matcher.group(3)); int hour =
     * Integer.parseInt(matcher.group(4)); int min =
     * Integer.parseInt(matcher.group(5));
     * 
     * if ((hour < 24) && (min < 60)) {
     * 
     * if (day.equals("31") && ((month.equals("4") || month.equals("6") ||
     * month.equals("9") || month.equals("11") || month.equals("04") ||
     * month.equals("06") || month.equals("09")))) { return false; // 4,6,9,11th
     * month only have 30 days } else if (month.equals("2") ||
     * month.equals("02")) { // leap year if ((year % 4 == 0) && (year % 400 ==
     * 0) && (year % 100 != 0)) { if (day.equals("30") || day.equals("31")) {
     * return false; } else { return true; } } else { if (day.equals("29") ||
     * day.equals("30") || day.equals("31")) { return false; } else { return
     * true; } } } else { return true; } } else { return false; } } else {
     * return false; } } return false; }
     * 
     * // Return today's date public static String TodayDate() { String
     * todaydate; todaydate = DateFormatToday(); return todaydate; }
     * 
     * // Return tomorrow's date public static String TomorrowDate() { String
     * tomorrowdate; tomorrowdate = DateFormatTomorrow(); return tomorrowdate; }
     * 
     * // format today's date into date format dd-MM-yyyy public static String
     * DateFormatToday() { String strDate = new
     * SimpleDateFormat("dd-MM-yyyy").format(new Date()); return strDate; }
     * 
     * // format tomorrow's date into date format dd-MM-yyyy public static
     * String DateFormatTomorrow() { Date today = new Date(); Date dayafter =
     * new Date(today.getTime() + TimeUnit.DAYS.toMillis(1)); String strDate =
     * new SimpleDateFormat("dd-MM-yyyy").format(dayafter);
     * 
     * return strDate;
     * 
     * }
     * 
     * // check if the time entered is not in the past public static boolean
     * aftertoday(String reminderdate) throws ParseException { DateFormat format
     * = new SimpleDateFormat("dd-MM-yyyy hh:mm"); Date date =
     * format.parse(reminderdate); Date today = new Date(); if
     * (date.before(today)) return false; return true;
     * 
     * }
     */
    
    
    /**
     * Convert today's date into date format
     * Optional to contain time of the day in hour and mins
     * @param string "today"
     * @return today in valid date format
     */
    
    public static String DateTimeToday(String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        String part1 = timeparts[0];
        new Date();
        Date todaydate;
        String strDate = new SimpleDateFormat("dd-MM-yyyy").format(new Date());
        if (timeparts.length != 1) {
            String part2 = timeparts[1];
            if (part1.contains("today"))
                return strDate.concat(" " + part2);
            else
                return strDate.concat(" " + part1);
        } else
            try {
                todaydate = new SimpleDateFormat("dd-MM-yyyy HH:mm").parse(strDate.concat(" 23:59"));
                return new SimpleDateFormat("dd-MM-yyyy HH:mm").format(todaydate);
            } catch (ParseException e) {
                throw new IllegalValueException(INVALID_FORMAT);
            }
    }
    /**
     * Convert today's date into date format
     * Optional to contain time of the day in hour and mins
     * @param string "tomorrow"
     * @return tomorrow in valid date format
     */
    public static String DateTimeTomorrow(String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        String part1 = timeparts[0];
        Date today = new Date();
        Date todaydate;
        new Date(today.getTime() + TimeUnit.DAYS.toMillis(1));
        String strDate = new SimpleDateFormat("dd-MM-yyyy").format(today.getTime() + TimeUnit.DAYS.toMillis(1));
        if (timeparts.length != 1) {
            String part2 = timeparts[1];
            if (part1.contains("today"))
                return strDate.concat(" " + part2);
            else
                return strDate.concat(" " + part1);
        } else
            try {
                todaydate = new SimpleDateFormat("dd-MM-yyyy HH:mm").parse(strDate.concat(" 23:59"));
                return new SimpleDateFormat("dd-MM-yyyy HH:mm").format(todaydate);
            } catch (ParseException e) {
                throw new IllegalValueException(INVALID_FORMAT);
            }
    }
    /**
     * Convert today's date into date format
     * Must contain time of the day in hour and mins
     * @param string "today"
     * @return today in valid date format
     */
    public static String FixedTimeToday(String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        String part1 = timeparts[0];
        Date today = new Date();
        String strDate = new SimpleDateFormat("dd-MM-yyyy").format(new Date());
        if (timeparts.length != 1) {
            String part2 = timeparts[1];
            if (part1.contains("today"))
                return strDate.concat(" " + part2);
            else
                return strDate.concat(" " + part1);
        } else
            throw new IllegalValueException(INVALID_FORMAT);
    }
    /**
     * Convert today's date into date format
     * Must contain time of the day in hour and mins
     * @param string "tomorrow"
     * @return tomorrow in valid date format
     */
    
    public static String FixedTimeTomorrow(String date) throws IllegalValueException {
        String[] timeparts = date.split(" ");
        String part1 = timeparts[0];
        Date today = new Date();
        Date todaydate;
        new Date(today.getTime() + TimeUnit.DAYS.toMillis(1));
        String strDate = new SimpleDateFormat("dd-MM-yyyy").format(today.getTime() + TimeUnit.DAYS.toMillis(1));
        if (timeparts.length != 1) {
            String part2 = timeparts[1];
            if (part1.contains("today"))
                return strDate.concat(" " + part2);
            else
                return strDate.concat(" " + part1);
        } else
            throw new IllegalValueException(INVALID_FORMAT);
    }
    
    

}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public AddCommand(String name, String duedate, String priority, String start, String end, String reminder,
            Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        String type = identifyActivityType(duedate, priority, start, end);

        if (type == "task") {

            this.toAdd = new Task(
                    new Name(name), 
                    new DueDate(duedate), 
                    new Priority(priority), 
                    new Reminder(reminder),
                    new UniqueTagList(tagSet));
        } else if (type == "event") {
            this.toAdd = new Event(new Name(name), new StartTime(start), new EndTime(new StartTime(start), end),
                    new Reminder(reminder), new UniqueTagList(tagSet));
        } else if (type == "float") {

            this.toAdd = new Activity(new Name(name), new Reminder(reminder), new UniqueTagList(tagSet));
        } else {
            assert false;
            throw new IllegalValueException(MESSAGE_INVALID_ACTIVITY_TYPE);
        }

    }
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    
    private final String typeOfList;

    public static final String MESSAGE_SUCCESS = "Listed all";
    
    public static final String MESSAGE_SUCCESS_TASK = "Listed tasks only";

    public static final String MESSAGE_SUCCESS_ACT = "Listed activities only";
    
    public static final String MESSAGE_SUCCESS_EVENT = "Listed events only";
    
    public static final String MESSAGE_INVALID_LIST_TYPE = "List Command should be followed by (optional) either 'activity', 'event' or 'task' only ";   
    
    public ListCommand(String typeOfList) {
        this.typeOfList= typeOfList;
    }

    @Override
    public CommandResult execute() {

      switch(typeOfList) {

      case "activity":   
          model.updateFilteredActivityListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_ACT);
      
      case "task":
    	  model.updateFilteredTaskListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_TASK);
       

      
      case "event":
          model.updateFilteredEventListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_EVENT);

      case "done":
          model.updateFilteredDoneListToShowAll();
          return new CommandResult(MESSAGE_SUCCESS_EVENT);
          default: //typeOfList equals ""
			model.updateFilteredListToShowAll();
			return new CommandResult(MESSAGE_SUCCESS);
		}
      
      }
    	
}
```
###### \java\seedu\address\model\activity\Activity.java
``` java
public class Activity implements ReadOnlyActivity {

    protected Name name;
    protected Reminder reminder;
    protected boolean isCompleted;
    protected UniqueTagList tags;

    /**
     * Every field must be present and not null.
     */
    public Activity(Name name, Reminder reminder, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, reminder, tags);
        this.name = name;
        this.reminder = reminder;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }

    /**
     * Copy constructor.
     */
    public Activity(ReadOnlyActivity source) {
        this(source.getName(), source.getReminder(), source.getTags());
        this.isCompleted =  source.getCompletionStatus();
    }

    @Override
    public Name getName() {
        return name;
    }
    
    public void setName(Name name) {
        this.name = name;
    }

    @Override
    public Reminder getReminder() {
        return reminder;
    }
    
    public void setReminder(Reminder reminder) {
        this.reminder = reminder;
    }
    
    @Override
    public boolean getCompletionStatus() {
        return isCompleted;
    }
    
    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
```
###### \java\seedu\address\model\activity\event\EndTime.java
``` java
public class EndTime extends DateTime {

    public static final String MESSAGE_ENDTIME_CONSTRAINTS = "Event's end time should only contain valid date";
    public static final String MESSAGE_ENDTIME_INVALID = "Event has already ended";
    public static final String MESSAGE_ENDTIME_NOTVALID = "Event end time is before start time";
    public String RecurringMessage;

    public EndTime(Calendar date) {
        super(date);
    }

    /**
     * Validates given Start Time.
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    public EndTime(StartTime starttime, String date) throws IllegalValueException {
        super(Calendar.getInstance());
        SimpleDateFormat start = new SimpleDateFormat("d-MM-yyyy HH:mm");
        String startstring = start.format(starttime.value.getTime());
        Date startdate;
        try {
            startdate = start.parse(startstring);
        } catch (ParseException e) {
            throw new IllegalValueException("Start Time Invalid");
        }
        // String[] recurring = starttime.RecurringMessage.split(" ");
        if (starttime.recurring) {
            if(date.equals("")) {
                recurring = true;
                String recu[] = starttime.RecurringMessage.split(" ");
                Calendar startcal = starttime.value;
                startcal.add(Calendar.HOUR_OF_DAY, 1);
                SimpleDateFormat format1 = new SimpleDateFormat("EEE HHmm");
                RecurringMessage = recu[0] + " " + format1.format(startcal.getTime());
                this.value = DateUtil.EndDateTime(startdate);
            }
            else {
                recurringEndTime(starttime, startdate, date);
            }
        } else if (date.equals("")) {
            this.value = DateUtil.EndDateTime(startdate);
        } else if(date.split(" ").length==1){
            Calendar startcal = starttime.value;
            SimpleDateFormat format1 = new SimpleDateFormat("d-MM-yyyy");
            date = format1.format(startcal) + " " + date;
            setDate(date);
        } else {
            setDate(date);
        }

        while ((this.value.before(Calendar.getInstance()))) {
            if (date.contains("mon") || date.contains("tue") || date.contains("wed")
                    || date.contains("thu") || date.contains("fri") || date.contains("sat")
                    || date.contains("sun"))
                this.value.add(Calendar.DAY_OF_WEEK, 7);                
                this.value.add(Calendar.DAY_OF_MONTH, 1);
        }
        if (this.value.before(starttime.value)) {
            while (this.value.before(starttime.value)) {
                if ((date.contains("mon") || date.contains("tue") || date.contains("wed") || date.contains("thu")
                        || date.contains("fri") || date.contains("sat") || date.contains("sun")))
                    this.value.add(Calendar.DAY_OF_WEEK, 7);
                else 
                    this.value.add(Calendar.DAY_OF_MONTH, 1);
            }
        }
    }

    private void recurringEndTime(StartTime starttime, Date startdate, String date) throws IllegalValueException {
        this.recurring = true;
        String[] recur;
        recur = date.split(" ");
        String[] recurstart;
        recurstart = starttime.RecurringMessage.split(" ");
        String[] recurendtime;
        if (recur.length == 1) {
            RecurringMessage = recurstart[0] + " " + recurstart[1] + " " + recur[0];
            date = recurstart[1] + " " + recur[0];
        } else if (date.contains("every")) {
            RecurringMessage = date;
            recurendtime = date.split(" ", 2);
            if (recurendtime.length == 1)
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            date = recurendtime[1];
        } else if (recur.length == 2) {
            RecurringMessage = "every " + date;
        } else
            throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
        setDate(date);

        Calendar cal = Calendar.getInstance();
        cal.setTime(startdate);
    }

    public Date convertStringtoDate(String date) throws IllegalValueException {
        ArrayList<SimpleDateFormat> DATE_FORMATS = new ArrayList<>();
        DATE_FORMATS.add(new SimpleDateFormat("d-MM-yyyy h:mm a"));
        DATE_FORMATS.add(new SimpleDateFormat("EEE, MMM d, yyyy h:mm a"));
        for (SimpleDateFormat sdf : DATE_FORMATS) {
            try {
                Date date1 = sdf.parse(date);
                return date1;
            } catch (ParseException e) {
                continue;
            }
        }
        throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
    }

    void setDate(String date) throws IllegalValueException {
        String[] recur = date.split(" ", 2);
        String recurfreq = recur[0];
        if (recur.length == 1)
            throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
        if (recurfreq.contains("day")) {
            date = "today " + recur[1];
        }
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
        }
        if (!date.equals("")) {
            Date taskDate = DateUtil.FixedDateConvert(date);

            if (taskDate == null) {
                assert false : "Date should not be null";
            } /*
               * else if (DateUtil.hasPassed(taskDate)) { throw new
               * IllegalValueException(MESSAGE_STARTTIME_INVALID); }
               */

            if (!isValidDate(date)) {
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            }
            this.value.setTime(taskDate);
            this.value.set(Calendar.MILLISECOND, 0);
            this.value.set(Calendar.SECOND, 0);
        }
    }

    public EndTime(String date) throws IllegalValueException {
        super(date);
        String[] recur;
        if (date != "") {
            if (date.contains("every")) {
                this.recurring = true;
                RecurringMessage = date;
                recur = date.split(" ", 2);
                if (recur.length == 1)
                    throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
                date = recur[1];
            }

            setDate(date);
        }
    }

    public String forDisplay() {
        if (this.value == null) {
            return "End:\t\t\t-";
        } else {
            return "End:\t\t\t".concat(this.toString());
        }
    }
}
```
###### \java\seedu\address\model\activity\event\Event.java
``` java
public class Event extends Activity implements ReadOnlyEvent{

    private StartTime startTime;
    private EndTime endTime;
    
    public Event(Name name, StartTime start, EndTime end, Reminder reminder, UniqueTagList tags) {
        super(name, reminder, tags);
        
//        assert !CollectionUtil.isAnyNull(start, end);
        this.startTime = start;
        this.endTime = end;
    }
    
    /**
     * Copy constructor.
     */
    public Event(ReadOnlyEvent source) {
        this(source.getName(), source.getStartTime(), source.getEndTime(), source.getReminder(), source.getTags());
        this.isCompleted =  source.getCompletionStatus();
    }
    
    @Override
    public StartTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(StartTime starttime) {
        this.startTime= starttime;
    }
    
    @Override
    public EndTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(EndTime endtime) {
        this.endTime= endtime;
    }
    
    /**
     * Checks if this event is currently ongoing.
     * @return true if the current time is between the start and end time.
     */
    @Override
    public boolean isOngoing() {
        return startTime.isBeforeNow() && endTime.isAfterNow();
    }

    /**
     * Checks if this event is over.
     * @return true if the current time is after the end time.
     */
    @Override
    public boolean isOver() {
        return endTime.isBeforeNow();
    }
    
    @Override
    public boolean getisOver() {
        return isOver();
    }

    @Override
    public String toStringCompletionStatus() {
        if(this.isOver()) {
            return "Event\nOver";
        } else if (this.isOngoing()) {
            return "Event\nOngoing";
        } else {
            return "";
        }
    }
    
    @Override
    public String displayTiming() {
        String message = "From ";
        if(this.getStartTime().recurring){
            checkrecurring();
            message = message.concat(" Every ");}
        if (isStartAndEndOnSameDate()) {
            SimpleDateFormat timeOnly = new SimpleDateFormat("h:mm aa");
            message = message.concat(startTime.toString() + " to " + timeOnly.format(endTime.getCalendarValue().getTime()));
        } else {
            message =  message.concat(startTime.toString() + " to " + endTime.toString());
        }
        return message;
    }
    
    private void checkrecurring() {
        if(this.getStartTime().value.before(Calendar.getInstance())){
        if(this.getStartTime().RecurringMessage.contains("sun")||this.getStartTime().RecurringMessage.contains("mon")||this.getStartTime().RecurringMessage.contains("tue")||this.getStartTime().RecurringMessage.contains("wed")||this.getStartTime().RecurringMessage.contains("thu")||this.getStartTime().RecurringMessage.contains("fri")||this.getStartTime().RecurringMessage.contains("sat")){
            this.getStartTime().value.add(Calendar.DAY_OF_WEEK, 7);
            this.getEndTime().value.add(Calendar.DAY_OF_WEEK, 7);
        }
        else{
            this.getEndTime().value.add(Calendar.DAY_OF_MONTH, 1);
            this.getStartTime().value.add(Calendar.DAY_OF_MONTH, 1);}}
        
    }

    private boolean isStartAndEndOnSameDate() {
        return startTime.getCalendarValue().get(Calendar.YEAR) == endTime.getCalendarValue().get(Calendar.YEAR)
                && startTime.getCalendarValue().get(Calendar.DAY_OF_YEAR) == endTime.getCalendarValue().get(Calendar.DAY_OF_YEAR);
    }
    
    @Override
    public boolean equals(Object other) {
        if (this == null || other == null) {
            return !(this == null ^ other == null);
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            return other == this // short circuit if same object
                    || (other instanceof ReadOnlyActivity // instanceof handles nulls
                    && ((Event) other).getName().equals(this.getName()) // state checks here onwards
                    && ((Event) other).getStartTime().equals(this.getStartTime())
                    && ((Event) other).getEndTime().equals(this.getEndTime())
                    && ((Event) other).getReminder().equals(this.getReminder()));
        }
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, startTime, endTime, reminder, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
    
}
```
###### \java\seedu\address\model\activity\event\StartTime.java
``` java
public class StartTime extends DateTime {

    public static final String MESSAGE_STARTTIME_CONSTRAINTS = "Event's start time should only contain valid date";
    public static final String MESSAGE_STARTTIME_INVALID = "Event has already started";
    public String RecurringMessage;

    public StartTime(Calendar date) {
        super(date);
    }

    /**
     * Validates given Start Time.
     *
     * @throws IllegalValueException
     *             if given Start time string is invalid.
     */
    public StartTime(String date) throws IllegalValueException {
        super(date);
        String[] recur;
        if (date != "") {
            if (date.contains("every")) {
                this.recurring = true;
                RecurringMessage = date;
                recur = date.split(" ", 2);
                if (recur.length == 1)
                    throw new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS);
                date = recur[1];
            }

            setDate(date);
        }

    }

    public void setDate(String date) throws IllegalValueException {
        String[] recur = date.split(" ", 2);
        String recurfreq = recur[0];
        if (recur.length == 1)
            throw new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS);
        if (recurfreq.equals("day")) {
            date = "today " + recur[1];
        }
        if (!date.equals("")) {
            Date taskDate = DateUtil.FixedDateConvert(date);

            if (taskDate == null) {
                assert false : "Date should not be null";
            } /*
               * else if (DateUtil.hasPassed(taskDate)) { throw new
               * IllegalValueException(MESSAGE_STARTTIME_INVALID); }
               */

            this.value.setTime(taskDate);
            this.value.set(Calendar.MILLISECOND, 0);
            this.value.set(Calendar.SECOND, 0);
            while (recurring && this.value.before(Calendar.getInstance())) {
                if (recurfreq.equals("mon") || recurfreq.contains("tue") || recurfreq.contains("wed")
                        || recurfreq.contains("thu") || recurfreq.contains("fri") || recurfreq.contains("sat")
                        || recurfreq.contains("sun"))
                    this.value.add(Calendar.DAY_OF_WEEK, 7);
                if (recurfreq.contains("day"))
                    this.value.add(Calendar.DAY_OF_MONTH, 1);
            }
        }
    }

    public String forDisplay() {
        if (this.value == null) {
            return "Start:\t\t-";
        } else {
            if(!recurring) {
                return "Start:\t\t".concat(this.toString());
            }
            else {
                SimpleDateFormat sdfRecurr = new SimpleDateFormat("EEEE, h:mm aa");
                return "Every ".concat(sdfRecurr.format(this.value.getTime()));
            }
        }
    }
}
```
###### \java\seedu\address\model\activity\Reminder.java
``` java
public class Reminder extends DateTime {

    public static final String MESSAGE_REMINDER_CONSTRAINTS = "Task reminder can only be in date format";
    public static final String MESSAGE_REMINDER_INVALID = "reminder time has passed";
    public String RecurringMessage;

    public Reminder(Calendar date) {
        super(date);
    }

    /**
     * Validates given reminder.
     *
     * @throws IllegalValueException
     *             if given reminder string is invalid.
     */
    public Reminder(String date) throws IllegalValueException {
        super(date);
        String[] recur;
        if (date != "") {
            if (date.contains("every")) {
                this.recurring = true;
                RecurringMessage = date;
                recur = date.split(" ", 2);
                if (recur.length == 1)
                    throw new IllegalValueException(MESSAGE_REMINDER_CONSTRAINTS);
                date = recur[1];
            }
            setDate(date);
        }
    }

    public void setDate(String date) throws IllegalValueException {
        String[] recur = date.split(" ", 2);
        String recurfreq = recur[0];
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_REMINDER_CONSTRAINTS);
        }
        if (recur.length != 1) {

            if (recurfreq.contains("day")) {
                date = "today " + recur[1];
            }

            if (!date.equals("")) {
                Date taskDate = DateUtil.FixedDateConvert(date);
                if (!isValidDate(date)) {
                    throw new IllegalValueException(MESSAGE_REMINDER_CONSTRAINTS);
                }
                if (taskDate == null) {
                    assert false : "Date should not be null";
                } /*
                   * else if (DateUtil.hasPassed(taskDate)) { throw new
                   * IllegalValueException(MESSAGE_REMINDER_INVALID);
                   */

                this.value.setTime(taskDate);
                this.value.set(Calendar.MILLISECOND, 0);
                this.value.set(Calendar.SECOND, 0);
            }

            while (recurring && this.value.before(Calendar.getInstance())) {
                if (recurfreq.contains("year"))
                    this.value.add(Calendar.YEAR, 1);
                if (recurfreq.contains("month"))
                    this.value.add(Calendar.MONTH, 1);
                else if (recurfreq.contains("mon") || recurfreq.contains("tue") || recurfreq.contains("wed")
                        || recurfreq.contains("thu") || recurfreq.contains("fri") || recurfreq.contains("sat")
                        || recurfreq.contains("sun"))
                    this.value.add(Calendar.DAY_OF_WEEK, 7);
                if (recurfreq.contains("day"))
                    this.value.add(Calendar.DAY_OF_MONTH, 1);
            }
        }
    }
    
    /**
     * Advances the reminder by a week (7 days) if it is recurring.
     */
    public void resetTime() {
        if (this.recurring) {
            this.value.add(Calendar.DAY_OF_MONTH, 7);
        }
    }

    public String forDisplay() {
        if (this.value == null) {
            return "Reminder:\t-";
        } else {
            if (!recurring) {
                return "Reminder:\t".concat(this.toString());
            }
            else {
                SimpleDateFormat sdfRecurr = new SimpleDateFormat("EEEE, h:mm aa");
                return "Reminder:\t".concat("Every " + sdfRecurr.format(this.value.getTime()));
            }
        }
    }

}
```
###### \java\seedu\address\model\activity\task\DueDate.java
``` java
/**
 * Represents a Task's DueDate in the Lifekeeper. Guarantees: immutable; is
 * valid as declared in {@link #isValidDueDate(String)}
 */
public class DueDate extends DateTime {

    public static final String MESSAGE_DUEDATE_CONSTRAINTS = "Task's DueDate should only contain valid date";
    public static final String MESSAGE_DUEDATE_INVALID = "Deadline is over";

    public DueDate(Calendar date) {
        super(date);
    }
    
    /**
     * Validates given Due Date.
     *
     * @throws IllegalValueException
     *             if given due date string is invalid.
     */
    public DueDate(String date) throws IllegalValueException {
        super(date);
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_DUEDATE_CONSTRAINTS);
        }
        
        if (!date.equals("")) {

            Date taskDate = DATE_PARSER.DueDateConvert(date);

            if (taskDate == null) {
                assert false : "Date should not be null";
            } /*else if (DateUtil.hasPassed(taskDate)) {
                throw new IllegalValueException(MESSAGE_DUEDATE_INVALID);
            }*/
            this.value.setTime(taskDate);
            this.value.set(Calendar.MILLISECOND, 0);
            this.value.set(Calendar.SECOND, 0);
        }
    }
    
    public String forDisplay() {
        if (this.value == null) {
            return "";
        } else {
            return "Due on ".concat(this.toString());
        }
    }
}
```
###### \java\seedu\address\model\activity\task\Task.java
``` java
public class Task extends Activity implements ReadOnlyTask {

    private DueDate duedate;
    private Priority priority;
    
    private static int DAYS_WARNING = -3;
    
    /**
     * Every field must be present and not null.
     */
    public Task(Name name, DueDate dueDate, Priority priority, Reminder reminder, UniqueTagList tags) {
        super(name, reminder, tags);
        
//        assert !CollectionUtil.isAnyNull(dueDate, priority);
        this.duedate = dueDate;
        this.priority = priority;
        this.isCompleted = false;
    }
    
    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDueDate(), source.getPriority(), source.getReminder(), source.getTags());
        this.isCompleted =  source.getCompletionStatus();
    }
    
    @Override
    public DueDate getDueDate() {
        return duedate;
    }
    
    public void setDueDate(DueDate duedate) {
        this.duedate = duedate;
    }
    
    @Override
    public Priority getPriority() {
        return priority;
    }
    
    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    @Override
    public boolean getCompletionStatus() {
        return isCompleted;
    }
    
    public void setCompletionStatus(boolean isComplete) {
        this.isCompleted = isComplete;
    }
    
    @Override
    public String toStringCompletionStatus() {
        if(isCompleted) {
            return "Completed";
        } else if (!isCompleted && this.isDueDateApproaching()) {
            return "Task Deadline Approaching";
        } else if(!isCompleted && this.hasPassedDueDate()){
            return "Task\nOverdue!";
        }
        
        return "";  
    }
    
    /**
     * Checks if the due date is approaching and returns true if so.
     * @return true if the current time is a certain number of days before the due date (default 3).
     */
    @Override
    public boolean isDueDateApproaching() {
        if(duedate.getCalendarValue() == null) {
            return false;           
        } else {
            Calendar cal = Calendar.getInstance();
            Date now = cal.getTime();
            cal.setTime(duedate.getCalendarValue().getTime());
            cal.add(Calendar.DAY_OF_MONTH, DAYS_WARNING);
            Date warningDate = cal.getTime();
            return warningDate.before(now)
                    && duedate.getCalendarValue().getTime().after(now);       
        }
    }
    
    /**
     * Returns true if the task is overdue.
     * @return true if the current time is after the task's due date.
     */
    @Override
    public boolean hasPassedDueDate() {
        if(duedate.getCalendarValue() == null) {
        	return false;        	
        } else {
            return duedate.isBeforeNow();     
        }
    }

    
    @Override
    public boolean equals(Object other) {
        if (this == null || other == null) {
            return !(this == null ^ other == null);
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            return other == this // short circuit if same object
                    || (other instanceof ReadOnlyActivity // instanceof handles nulls
                    && ((Task) other).getName().equals(this.getName()) // state checks here onwards
                    && ((Task) other).getDueDate().equals(this.getDueDate())
                    && ((Task) other).getPriority().equals(this.getPriority())
                    && ((Task) other).getReminder().equals(this.getReminder()));
        }
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, duedate, priority, reminder, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
}
```
###### \java\seedu\address\model\Model.java
``` java
    void updateFilteredEventListToShowAll();

    void updateFilteredActivityListToShowAll();

    void updateFilteredTaskListToShowAll();

    void updateFilteredByTagListToShowAll(String tag);

    void updateFilteredDoneListToShowAll();



    
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredPersons.setPredicate(p->
        p.getCompletionStatus() == false && p.getisOver() == false);
    }
    
    @Override
    public void updateFilteredByTagListToShowAll(String tag) {
        filteredPersons.setPredicate(p->
        p.getTags().contains1(tag));
    }
    
    @Override
    public void updateFilteredTaskListToShowAll() {
        filteredPersons.setPredicate(p->
        p.getClass().getSimpleName().equalsIgnoreCase("Task"));
    }
    
    @Override
    public void updateFilteredDoneListToShowAll() {
        filteredPersons.setPredicate(p->
        p.getCompletionStatus() == true || p.getisOver() == true);
    }
    
    @Override
    public void updateFilteredActivityListToShowAll() {
        filteredPersons.setPredicate(p->
        p.getClass().getSimpleName().equalsIgnoreCase("Activity"));
    }
    
    @Override
    public void updateFilteredEventListToShowAll() {
        filteredPersons.setPredicate(p->
        p.getClass().getSimpleName().equalsIgnoreCase("Event"));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords){
        updateFilteredPersonList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredPersonList(Expression expression) {
        filteredPersons.setPredicate(expression::satisfies);
    }
```
###### \java\seedu\address\storage\XmlAdaptedActivity.java
``` java
        case "event":
            type = "event";
            line1 = ((ReadOnlyEvent) source).getStartTime().toSave();
            line2 = ((ReadOnlyEvent) source).getEndTime().toSave();
            if (((ReadOnlyEvent) source).getStartTime().value != null) {
                if (((ReadOnlyEvent) source).getStartTime().recurring)
                    recurring = true;
                else
                    recurring = false;
            }
            if (((ReadOnlyEvent) source).getStartTime() != null
                    && ((ReadOnlyEvent) source).getStartTime().RecurringMessage!=null)
                starttimeRecurring = ((ReadOnlyEvent) source).getStartTime().RecurringMessage;
            if (((ReadOnlyEvent) source).getEndTime() != null)
                    if(((ReadOnlyEvent) source).getEndTime().RecurringMessage!=null)
                endtimeRecurring = ((ReadOnlyEvent) source).getEndTime().RecurringMessage;
            break;

        }
    }

    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source
     *            future changes to this will not affect the created
     *            XmlAdaptedActivity
     */
    public XmlAdaptedActivity(ReadOnlyTask source) {
        type = "task";
        name = source.getName().fullName;
        line1 = source.getDueDate().toString();
        line2 = source.getPriority().value;
        reminder = source.getReminder().toString();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        if (source.getCompletionStatus()) {
            completion = true;
        } else {
            completion = false;
        }
    }
```
###### \java\seedu\address\storage\XmlAdaptedActivity.java
``` java
    public Activity toModelType() throws IllegalValueException {
        final List<Tag> activityTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            activityTags.add(tag.toModelType());
        }

        final Name name = new Name(this.name);
        final Reminder reminder = new Reminder(this.reminder);
        reminder.recurring= this.recurring;
        reminder.RecurringMessage=this.reminderRecurring;
        final UniqueTagList tags = new UniqueTagList(activityTags);

        switch (this.type) {

        case "activity":
            Activity act= new Activity(name, reminder, tags);
            act.setCompletionStatus(this.completion);
            return act;

        case "task":
            final DueDate duedate = new DueDate(this.line1);
            final Priority priority = new Priority(this.line2);
            // How to use Image to set priority?

            Task task = new Task(name, duedate, priority, reminder, tags);
            task.setCompletionStatus(this.completion);
            return task;
            
        case "event":

            final StartTime start = new StartTime(this.line1);
            start.recurring=this.recurring;
            start.RecurringMessage= this.starttimeRecurring;
            final EndTime end = new EndTime(this.line2);
            end.recurring = this.recurring;
            end.RecurringMessage = this.endtimeRecurring;
            return new Event(name, start, end, reminder, tags);

        }
        return null;

    }
}
```
