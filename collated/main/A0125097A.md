# A0125097A
###### \bin\view\ActivityListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="100.0" minWidth="10.0" prefWidth="100.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" maxHeight="150.0" minHeight="105.0" prefHeight="115.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER_LEFT" spacing="5">
                            <children>
                                <HBox>
                                    <Label fx:id="id" styleClass="cell_big_label" />
                                    <Label fx:id="name" styleClass="cell_big_label" text="\$first" />
                                </HBox>
                                <Label fx:id="tags" styleClass="cell_small_label" text="\$tags" />
                            </children>
                        </HBox>
                        <Label fx:id="line1" styleClass="cell_small_label" text="\$line1" />
                        <Label fx:id="line2" styleClass="cell_small_label" text="\$line2" />
                        <Label fx:id="reminder" styleClass="cell_small_label" text="\$reminder" />
                        <Label fx:id="completion" styleClass="cell_small_label" text="\$completion" />
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
###### \docs\UserGuide.md
``` md

# User Guide

* [Quick Start](#quick-start)
* [Features](#features)
* [FAQ](#faq)
* [Command Summary](#command-summary)

## Quick Start

0. Ensure you have Java version `1.8.0_60` or later installed in your Computer.<br>
   > Having any Java 8 version is not enough. <br>
   This app will not work with earlier versions of Java 8.
   
1. Download the latest `lifekeeper.jar` from the [releases](../../../releases) tab.
2. Copy the file to the folder you want to use as the home folder for your Lifekeeper.
3. Double-click the file to start the app. The GUI should appear in a few seconds. 
   > <img src="images/UIprototype.png" width="600">

4. Type the command in the command box and press <kbd>Enter</kbd> to execute it. <br>
   e.g. typing **`help`** and pressing <kbd>Enter</kbd> will open the help window. 
5. Some example commands you can try:
   * **`list`** : lists all activities
   * **`add`**` CS2103 T7A1 d/6 Oct 2016 p/2 r/5 Oct 2016 1800 t/teamC2` : 
     adds an activity named `CS2103 T7A1` to the Lifekeeper.
   * **`delete`**` 3` : deletes the 3rd activity shown in the current list
   * **`exit`** : exits the app
6. Refer to the [Features](#features) section below for details of each command.<br>


## Features

> **Command Format**
> * Words in `UPPER_CASE` are the parameters.
> * Items in `[SQUARE_BRACKETS]` are optional.
> * Items in `{CURLY_BRACES}` cannot be input together with other items within a separate `{CURLY_BRACES}`
> * Items with `...` after them can have multiple instances.
> * The order of parameters is not fixed.

#### Viewing help : `help`
Format: `help`

> Help is also shown if you enter an incorrect command e.g. `abcd`
 
#### Adding an activity: `add`

Adds an activity to Lifekeeper<br>
Format: `add ACTIVITY_NAME {[d/DUEDATE] [p/PRIORITY_LEVEL]}{[s/START_TIME] [e/END_TIME]} [r/REMINDER] [t/TAG]...` 

> Activities can have only either `[d/DUEDATE] [p/PRIORITY_LEVEL]` or `[s/START_TIME] [e/END_TIME]` 
> Activities can have any number of tags (including 0)

`DUEDATE` accepts `Date Time` format input and variable inputs namely:
* `tomorrow [TIME]`
* `today [TIME]`

`PRIORITY_LEVEL` has to be an integer equal or larger than 1, with `1` being the top priority.

`START_TIME` accepts `Date Time` format input and variable inputs namely:
* `tomorrow [TIME]`
* `today [TIME]`

`END_TIME` accepts `Date Time` format input and variable inputs namely:
* `tomorrow [TIME]`
* `today [TIME]`


`REMINDER` accepts `Date Time` format input and variable inputs namely:
* `tomorrow`
* `today`
* `[TIME] before` sets reminder at the specified time before the `DUEDATE`. e.g. `0015 before` for a reminder 15 minutes before the `DUEDATE`.

Examples: 
* `add Grocery Shopping`
* `add Assignment 1 d/Tomorrow p/1 r/Today 2000`
* `add Project Report d/Tomorrow 1700 t/school`
* `add CS2103 T7A1 d/6 Oct 2016 p/2 r/5 Oct 2016 1800 t/teamC2`
* `add Lunch s/1200 e/1300`
* `add Executive Meeting s/tomorrow 0900 e/tomorrow 1200`
* `add Concert s/tomorrow 1800 e/tomorrow 2000 t/Leisure`

```
###### \docs\UserGuide.md
``` md

#### Finding activities by name or tag(s): `find`
Finding all activities containing the queried keyword in their name
* Finds activities whose names contain any of the given keywords.<br>
* Format: `find KEYWORD [MORE_KEYWORDS]`

> * The search is not case sensitive. e.g `study` will match `Study`
> * The order of the keywords matters. e.g. `Assignment Due` will not match `Due Assignment`
> * Words containing the keywords will be matched e.g. `Exam` will match `Exams`
> * Tasks matching at least one keyword will be returned (i.e. `OR` search).
    e.g. `Shopping` will match `Clothes Shopping`

Examples: 
* `find activities Homework Assignment`<br>
  Returns Any activities with words containing `Homework`, `homework`, `Assignment`, or `assignment` in their names.

```
###### \src\main\java\seedu\address\logic\commands\Command.java
``` java
    /**
     * Raises an event to indicate an attempt to execute an incorrect command
     * @return "float", "task" or "event"
     * @throws IllegalValueException if Activity type cannot be determined
     */
    protected String identifyActivityType (String duedate, String priority, String start, String end) 
            throws IllegalValueException {
        
        if( (!duedate.isEmpty() || !priority.isEmpty()) && (!start.isEmpty() || !end.isEmpty()) ) {
            throw new IllegalValueException(MESSAGE_INVALID_ACTIVITY_TYPE);
        } else if ( duedate.isEmpty() && priority.isEmpty() && start.isEmpty() && end.isEmpty()){
            return "float";
        }
        
        if(!duedate.isEmpty() || !priority.isEmpty()) {
            return "task";
        } else if (start.isEmpty()) {
            throw new IllegalValueException(MESSAGE_INVALID_EVENT);
        } else {
            return "event";
        }
        
    }
    
}
```
###### \src\main\java\seedu\address\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the Lifekeeper.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";

    public final int targetIndex;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyActivity> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyActivity taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.deleteTask(taskToDelete);
            
            PreviousCommand deleteCommand = new PreviousCommand(COMMAND_WORD,targetIndex,taskToDelete);
            PreviousCommandsStack.push(deleteCommand);
            
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### \src\main\java\seedu\address\logic\commands\DoneCommand.java
``` java
/**
 * Marks the completion of a task identified using it's last displayed index
 * from the Lifekeeper.
 */
public class DoneCommand extends Command {

	public static final String COMMAND_WORD = "done";

	public static final String MESSAGE_USAGE = COMMAND_WORD
			+ ": Marks the completion of the task identified by the index number shown in the last task listing.\n"
			+ "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1";

	public static final String MESSAGE_DONE_TASK_SUCCESS = "Marked task as Completed: %1$s";
	public static final String MESSAGE_TASK_COMPLETED = "Task is already Completed";
	public static final String MESSAGE_EVENT_INVALID = "Events cannot be marked as completed";
    
	
	public final int targetIndex;

	public DoneCommand(int targetIndex) {
		this.targetIndex = targetIndex;
	}

	@Override
	public CommandResult execute() {

		UnmodifiableObservableList<ReadOnlyActivity> lastShownList = model.getFilteredTaskList();

		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyActivity taskToMark = lastShownList.get(targetIndex - 1);

		if(taskToMark.getClass().getSimpleName().equalsIgnoreCase("event")){
		    return new CommandResult(MESSAGE_EVENT_INVALID);
		}
		    
		
		if (taskToMark.getCompletionStatus() == false) {

			Activity unmarkedTask = Activity.create(taskToMark);
			
			boolean isComplete = true;
			try {
				model.markTask(unmarkedTask, isComplete);

				PreviousCommand doneCommand = new PreviousCommand(COMMAND_WORD, unmarkedTask);
				PreviousCommandsStack.push(doneCommand);

			} catch (TaskNotFoundException tnfe) {
				assert false : "The target task cannot be missing";
			}
			return new CommandResult(String.format(MESSAGE_DONE_TASK_SUCCESS, taskToMark));

		} else {
			return new CommandResult(String.format(MESSAGE_TASK_COMPLETED));
		}
	}
}

```
###### \src\main\java\seedu\address\logic\commands\PreviousCommand.java
``` java
/** 
 * Carries information of previous command: Command word and task.
 */
public class PreviousCommand {

	public String COMMAND_WORD;
	public Activity updatedTask;
	public Activity oldTask;
	public int index;

	
	public PreviousCommand(String command, Activity task)
	{
		COMMAND_WORD = command;
		updatedTask = task;
		oldTask = null;
	}
	
	public PreviousCommand(String command, int index, ReadOnlyActivity task)
	{
		COMMAND_WORD = command;
		this.index = index;
		String type = task.getClass().getSimpleName().toLowerCase();
			
		switch (type) {
        case "activity":
    		updatedTask = new Activity(task);
            break;
        
        case "task":
        	updatedTask = new Task((ReadOnlyTask) task);
            break;
        
        case "event":
        	updatedTask = new Event((ReadOnlyEvent) task);
            break;
        
        default:
            assert false : "Invalid class type";
        }
		
		
		oldTask = null;
	}
		
	public PreviousCommand(String command, Activity originalActivity, Activity editedActivity) {
        COMMAND_WORD = command;
        updatedTask = editedActivity;
                
            oldTask = originalActivity;

	}

	public String getCommand()
	{
		return COMMAND_WORD;
	}
	
	public Activity getUpdatedTask()
	{
		return updatedTask;
	}
	  
	public Activity getOldTask()
	{
	    return oldTask;
    }
	   
	public int getIndex()
	{
	    return index;
    }
	
}
```
###### \src\main\java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undo previous add, delete and edit commands.
 */
public class UndoCommand extends Command {

	public static final String COMMAND_WORD = "undo";

	public static final String MESSAGE_USAGE = COMMAND_WORD;

	public static final String MESSAGE_SUCCESS = "Undo Command: %1$s";
	public static final String MESSAGE_END_OF_UNDO = "There is no more commands to undo";

	public static final String MESSAGE_UNDO_ADD_SUCCESS = "Undo: Adding of new task: %1$s";
	public static final String MESSAGE_UNDO_DELETE_SUCCESS = "Undo: Deleting task: %1$s";
    public static final String MESSAGE_UNDO_EDIT_SUCCESS = "Undo: Editting task from: %1$s\nto: %2$s";
    public static final String MESSAGE_UNDO_DONE_SUCCESS = "Undo: Marked task as Completed: %1$s";
	   
	public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the Lifekeeper";
	
	@Override
	public CommandResult execute() {

		if (!PreviousCommandsStack.empty()) {
			PreviousCommand toUndo = PreviousCommandsStack.pop();

			switch (toUndo.getCommand()) {

			case AddCommand.COMMAND_WORD:
				return undoAdd(toUndo);

			case DeleteCommand.COMMAND_WORD:
				return undoDelete(toUndo);
				
            case EditCommand.COMMAND_WORD:
                return undoEdit(toUndo);
                
            case DoneCommand.COMMAND_WORD:
                return undoDone(toUndo);
			}

		}
		
			return new CommandResult(MESSAGE_END_OF_UNDO);
	}


	/**
	 * Undo Add command which was previously called
	 */
	private CommandResult undoAdd(PreviousCommand toUndo) {
		Activity taskToDelete = toUndo.getUpdatedTask();

		try {
			model.deleteTask(taskToDelete);
		} catch (TaskNotFoundException tnfe) {
			assert false : "The target task cannot be missing";
		}

		return new CommandResult(String.format(MESSAGE_UNDO_ADD_SUCCESS, taskToDelete));
	}

	/**
	 * Undo Delete command which was previously called
	 */
	private CommandResult undoDelete(PreviousCommand toUndo) {
		Activity taskToAdd = toUndo.getUpdatedTask();
        int index = toUndo.getIndex();
		
		try {
			model.undoDelete(index,taskToAdd);
			
		} catch (UniqueActivityList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

		return new CommandResult(String.format(MESSAGE_UNDO_DELETE_SUCCESS, taskToAdd));
	}

	/**
     * Undo Edit command which was previously called
     */
    private CommandResult undoEdit(PreviousCommand toUndo) {
        Activity taskToEdit = toUndo.getUpdatedTask();
        Activity edittedTask = toUndo.getOldTask();
        Activity taskAfterEdit = new Activity(taskToEdit);
        
        try {
            Activity taskBeforeEdit = model.undoEditTask(taskToEdit,edittedTask);
            
            return new CommandResult(String.format(MESSAGE_UNDO_EDIT_SUCCESS, taskBeforeEdit, taskAfterEdit));
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task to be edited cannot be missing";
        return new CommandResult("not found");
        } catch (UniqueActivityList.DuplicateTaskException e) {
            assert false : "The unedited task should not be a duplicate of the edited task";
        return new CommandResult("duplicate");
        } 
    }

	/**
     * Undo Edit command which was previously called
     */
	private CommandResult undoDone(PreviousCommand toUndo) {
		boolean isComplete = false;
		Activity unmarkedTask = toUndo.getUpdatedTask();
        try {
    		model.markTask(unmarkedTask, isComplete);
    		
            return new CommandResult(String.format(MESSAGE_UNDO_DONE_SUCCESS, unmarkedTask));
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task to be edited cannot be missing";
        }
		return null;
	}

	
}
```
###### \src\main\java\seedu\address\ui\ActivityCard.java
``` java
public class ActivityCard extends UiPart {

    private static final String FXML = "ActivityListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label line1;
    @FXML
    private Label line2;
    @FXML
    private Label reminder;
    @FXML
    private Label tags;
    @FXML
    private Label completion;

    private ReadOnlyActivity activity;
    private int displayedIndex;

    public ActivityCard() {

    }

    public static ActivityCard load(ReadOnlyActivity person2, int displayedIndex) {
        ActivityCard card = new ActivityCard();
        card.activity = person2;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        
        
        name.setText(activity.getName().fullName);
        id.setText(displayedIndex + ". ");
        
        if(activity.getClass().getSimpleName().equalsIgnoreCase("task")) {
            line1.setText(((ReadOnlyTask) activity).getDueDate().forDisplay());
            line2.setText(((ReadOnlyTask) activity).getPriority().forDisplay());  
        
        } else if(activity.getClass().getSimpleName().equalsIgnoreCase("event")) {
            line1.setText(((ReadOnlyEvent) activity).getStartTime().forDisplay());
            line2.setText(((ReadOnlyEvent) activity).getEndTime().forDisplay());   
        } else {
            line1.setText("");
            line2.setText("");
        }

        reminder.setText(activity.getReminder().forDisplay());
        
        tags.setText(activity.tagsString());
        completion.setText(activity.toStringCompletionStatus());
        if(activity.getCompletionStatus() == true) {
        	cardPane.setStyle("-fx-background-color: springgreen;");
        } else if(activity.passedDueDate()){
            cardPane.setStyle("-fx-background-color: red;");
        } /*else if (activity.getClass().getSimpleName().equalsIgnoreCase("task")) {

            switch (((ReadOnlyTask) activity).getPriority().value) {

            case "1":
                cardPane.setStyle("-fx-background-color: lightyellow;");
                break;
            case "2":
                cardPane.setStyle("-fx-background-color: moccasin;");
                break;
            case "3":
                cardPane.setStyle("-fx-background-color: salmon;");
                break;
            }
        }*/
        
        
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \src\main\resources\view\ActivityListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="100.0" minWidth="10.0" prefWidth="100.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" maxHeight="150.0" minHeight="105.0" prefHeight="115.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER_LEFT" spacing="5">
                            <children>
                                <HBox>
                                    <Label fx:id="id" styleClass="cell_big_label" />
                                    <Label fx:id="name" styleClass="cell_big_label" text="\$first" />
                                </HBox>
                                <Label fx:id="tags" styleClass="cell_small_label" text="\$tags" />
                            </children>
                        </HBox>
                        <Label fx:id="line1" styleClass="cell_small_label" text="\$line1" />
                        <Label fx:id="line2" styleClass="cell_small_label" text="\$line2" />
                        <Label fx:id="reminder" styleClass="cell_small_label" text="\$reminder" />
                        <Label fx:id="completion" styleClass="cell_small_label" text="\$completion" />
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
###### \src\test\java\guitests\DeleteCommandTest.java
``` java
public class DeleteCommandTest extends AddressBookGuiTest {

    @Test
    public void delete() {

        //delete the first in the list
        TestActivity[] currentList = td.getTypicalPersons();
        int targetIndex = 1;
        assertDeleteSuccess(targetIndex, currentList);

        //delete the last in the list
        currentList = TestUtil.removePersonFromList(currentList, targetIndex);
        targetIndex = currentList.length;
        assertDeleteSuccess(targetIndex, currentList);

        //delete from the middle of the list
        currentList = TestUtil.removePersonFromList(currentList, targetIndex);
        targetIndex = currentList.length/2;
        assertDeleteSuccess(targetIndex, currentList);

        //invalid index
        commandBox.runCommand("delete " + currentList.length + 1);
        assertResultMessage("The task index provided is invalid");

    }

    /**
     * Runs the delete command to delete the person at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to delete the first person in the list, 1 should be given as the target index.
     * @param currentList A copy of the current list of persons (before deletion).
     */
    private void assertDeleteSuccess(int targetIndexOneIndexed, final TestActivity[] currentList) {
        TestActivity personToDelete = currentList[targetIndexOneIndexed-1]; //-1 because array uses zero indexing
        TestActivity[] expectedRemainder = TestUtil.removePersonFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("delete " + targetIndexOneIndexed);

        //confirm the list now contains all previous persons except the deleted person
        assertTrue(personListPanel.isListMatching(expectedRemainder));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_DELETE_TASK_SUCCESS, personToDelete.getAsText()));
    }

}
```
###### \src\test\java\guitests\guihandles\ActivityCardHandle.java
``` java
public class ActivityCardHandle extends GuiHandle {
    private static final String NAME_FIELD_ID = "#name";
    private static final String REMINDER_FIELD_ID = "#reminder";
    private static final String DUEDATE_FIELD_ID = "#line1";
    private static final String PRIORITY_FIELD_ID = "#line2";
    private static final String STARTTIME_FIELD_ID = "#line1";
    private static final String ENDTIME_FIELD_ID = "#line2";
    

    private Node node;

    public ActivityCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node){
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getFullName() {
        return getTextFromLabel(NAME_FIELD_ID);
    }

    public String getReminder() {
        return getTextFromLabel(REMINDER_FIELD_ID);
    }
    
    public String getDueDate() {
    	return getTextFromLabel(DUEDATE_FIELD_ID);
    }
    
    public String getPriority() {
    	return getTextFromLabel(PRIORITY_FIELD_ID);
    }
    
    public String getStartTime() {
    	return getTextFromLabel(STARTTIME_FIELD_ID);
    }
    
    public String getEndTime() {
    	return getTextFromLabel(ENDTIME_FIELD_ID);
    }
```
