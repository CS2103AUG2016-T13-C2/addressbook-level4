# A0125680H
###### \java\seedu\lifekeeper\commons\util\DateUtil.java
``` java
    /**
     * Validate date format with regular expression
     * 
     * @param date
     * @return true valid date format, false invalid date format
     * 
     */
    public static boolean validate(String date) {
        Date validDate;

        for (SimpleDateFormat sdf : DATE_FORMATS) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return true;
                }
            } catch (ParseException e) {
                continue;
            }
        }
        for (SimpleDateFormat sdf : DATE_FORMATS1) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return true;
                }
            } catch (ParseException e) {
                continue;
            }
        }

        return false;
    }

    /**
     * Convert valid reminder date input into date format Optional to contain
     * time of the day in hour and mins
     * 
     * @param date
     * @return the date in valid date format
     * @throws IllegalValueException
     */
```
###### \java\seedu\lifekeeper\commons\util\DateUtil.java
``` java
    /**
     * Checks whether the format entered will be accepted by LifeKeeper
     * 
     * @param format
     * @return boolean indicating whether format is accepted.
     */
    public boolean isValidFormat(String format) {
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        for (SimpleDateFormat a : DATE_FORMATS) {
            if (a.equals(formatter)) {
                return true;
            }
        }
        return false;
    }

    public static boolean recurValidDate(String date) {
        Date validDate;

        for (SimpleDateFormat sdf : TIME_FORMATS) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return true;
                }
            } catch (ParseException e) {
                continue;
            }
        }
        return false;
    }

```
###### \java\seedu\lifekeeper\logic\commands\EditCommand.java
``` java
/**
 * Edits the activity in the indicated index
 * by replacing data specified in the new parameters.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the indexed task from Lifekeeper. \n"
            + "Parameters: INDEX (must be a positive integer) [n/TASK_NAME] [c/CATEGORY] [d/DEADLINE] p/PRIORITY_LEVEL r/REMINDER [t/TAG]...\n"
            + "Example: " + COMMAND_WORD + " 1 n/CS2103 T8A2 d/15-10-2016 p/3 r/12-01-2016 t/CS t/project";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task from: %1$s\nto: %2$s";
    public static final String MESSAGE_ENTRY_EXISTS = "An existing entry already contains the specified parameters.";
    public static final String MESSAGE_ACTIVITY_MISMATCH = "Task cannot be changed to event and vice versa.";

    public final int targetIndex;

    private final String newParamsType;

    public final Activity newParams;

    /**
     * Set parameters to null if they are not provided.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public EditCommand(int targetIndex, String name, String duedate, String priority, String start, String end,
            String reminder, Set<String> tags) throws IllegalValueException {
        this.targetIndex = targetIndex;

        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        newParamsType = identifyActivityType(duedate, priority, start, end);

        switch (newParamsType.toLowerCase()) {
        case ("float"):
            this.newParams = new Activity(
                    new Name(name), 
                    new Reminder(reminder), 
                    new UniqueTagList(tagSet)
                    );
        
            break;
        case ("task"):
            this.newParams = new Task(
                    new Name(name), 
                    new DueDate(duedate), 
                    new Priority(priority),
                    new Reminder(reminder), 
                    new UniqueTagList(tagSet)
                    );

            if (duedate.length() > 0) {
                if (((Task) newParams).getDueDate().isBeforeNow()) {
                    throw new IllegalValueException(DueDate.MESSAGE_DUEDATE_INVALID);
                }
            }
            break;
        case ("event"):
            this.newParams = new Event(
                    new Name(name), 
                    new StartTime(start), 
                    new EndTime(new StartTime(start), end),
                    new Reminder(reminder), 
                    new UniqueTagList(tagSet)
                    );

            if (((Event) newParams).getStartTime().isBeforeNow()) {
                throw new IllegalValueException(StartTime.MESSAGE_STARTTIME_INVALID);
            }

            break;
        default:
            assert false : "Invalid method output: identifyActivityType";
            throw new IllegalValueException(MESSAGE_INVALID_ACTIVITY_TYPE);
        }
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<Activity> lastShownList = model.getFilteredTaskListForEditing();

        Activity taskToEdit = lastShownList.get(targetIndex - 1);
        String taskToEditType = taskToEdit.getClass().getSimpleName();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        if (taskToEditType.equalsIgnoreCase("task") && newParamsType.equalsIgnoreCase("event")
                || taskToEditType.equalsIgnoreCase("event") && newParamsType.equalsIgnoreCase("task")) {
            return new CommandResult(MESSAGE_ACTIVITY_MISMATCH);
        }

        try {
            Activity oldTask = produceNewActivityObject(taskToEdit);
            Activity editedTask = model.editTask(taskToEdit, newParams);

            PreviousCommand editCommand = new PreviousCommand(COMMAND_WORD, oldTask, editedTask);
            PreviousCommandsStack.push(editCommand);

            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, oldTask, editedTask));
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task to be edited cannot be missing";
            return new CommandResult("");
        } catch (DuplicateTaskException dte) {
            return new CommandResult(MESSAGE_ENTRY_EXISTS);
        }
    }

    private Activity produceNewActivityObject(Activity original) {
        String type = original.getClass().getSimpleName().toLowerCase();

        switch (type) {
        case "activity":
            return new Activity(original);
        case "task":
            return new Task((ReadOnlyTask) original);
        default: // case "event":
            return new Event((ReadOnlyEvent) original);
        }

    }

}
```
###### \java\seedu\lifekeeper\logic\commands\OpenCommand.java
``` java
/**
* Loads data from the specified file into the Lifekeeper App.
*/
public class OpenCommand extends Command {
    public static final String COMMAND_WORD = "open";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Allows the save file location to be specified.\n"
            + "File name cannot consist of any of the following characters: '<', '>', ':', '\"', '|', '?', '*'\n"
            + "Example: " + COMMAND_WORD + " folder" + System.getProperty("file.separator") + "file.xml";

    public static final String OPEN_MESSAGE = "Loaded data from file: %1$s";
    public static final String NO_SUCH_FILE_MESSAGE = "The specified file doesn't exist";
    
    private final String openPath;

    public OpenCommand(String filePath) {
        filePath.replace("/", System.getProperty("file.separator"));
        filePath.replace("\\", System.getProperty("file.separator"));
        
        if (!filePath.endsWith(".xml")) {
            filePath += ".xml";
        }
        
        this.openPath = filePath;
    }

    @Override
    public CommandResult execute() {
        String oldPath = XmlLifekeeperStorage.getFilePathForSaveCommand();
        File openFile = new File(openPath);
        String filePath = openFile.getAbsolutePath();
        
        if (FileUtil.isValidFilePath(openPath) && openFile.exists()) {
            EventsCenter.getInstance().post(new OpenFileChooserEvent(filePath));
        } else {
            EventsCenter.getInstance().post(new OpenFileChooserEvent(""));
        }
        
        if (oldPath.equals(XmlLifekeeperStorage.getFilePathForSaveCommand())) {
            return new CommandResult(NO_SUCH_FILE_MESSAGE);
        } else {
            return new CommandResult(String.format(OPEN_MESSAGE, XmlLifekeeperStorage.getFilePathForSaveCommand()));
        }
    }

}
```
###### \java\seedu\lifekeeper\logic\commands\SaveCommand.java
``` java
/**
 * Saves the Lifekeeper data to the file directory specified by the user.
 */
public class SaveCommand extends Command {
    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Allows the save file location to be specified.\n"
            + "File name cannot consist of any of the following characters: '<', '>', ':', '\"', '|', '?', '*'\n"
            + "Example: " + COMMAND_WORD + " folder" + System.getProperty("file.separator") + "file.xml";

    public static final String SAVE_MESSAGE = "New save location: %1$s";
    
    private final String savePath;

    public SaveCommand(String filePath) {
        filePath.replace("/", System.getProperty("file.separator"));
        filePath.replace("\\", System.getProperty("file.separator"));
        this.savePath = filePath;
    }

    @Override
    public CommandResult execute() {
        File saveFile = new File(savePath);
        if (FileUtil.isValidFilePath(savePath)) {
            String filePath = saveFile.getAbsolutePath();
            
            if (!filePath.endsWith(".xml")) {
                filePath += ".xml";
            }
            
            EventsCenter.getInstance().post(new SaveFileChooserEvent(filePath));
            return new CommandResult(String.format(SAVE_MESSAGE, XmlLifekeeperStorage.getFilePathForSaveCommand()));
        } else {
            EventsCenter.getInstance().post(new SaveFileChooserEvent(""));
            return new CommandResult(String.format(SAVE_MESSAGE, XmlLifekeeperStorage.getFilePathForSaveCommand()));
        }
    }
}
```
###### \java\seedu\lifekeeper\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the edit activity command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args){
        final Matcher matcherEdit = PERSON_EDIT_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if(!matcherEdit.matches()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        String indexString = matcherEdit.group("targetIndex");
        Optional<Integer> index = parseIndex(indexString);
        
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        String params = " ".concat(matcherEdit.group("parameters").trim());
        final Matcher matcherParams = PERSON_EDIT_PARAMETERS_ARGS_FORMAT.matcher(params);
        
        if(!matcherParams.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        try {
            return new EditCommand(index.get(), 
                    getElement(matcherParams.group("task"), " n/"),
                    getElement(matcherParams.group("duedate")," d/"),
                    getElement(matcherParams.group("priority")," p/"),
                    getElement(matcherParams.group("start")," s/"),
                    getElement(matcherParams.group("end")," e/"),
                    getElement(matcherParams.group("reminder")," r/"),
                    getTagsFromArgs(matcherParams.group("tagArguments"))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSelect(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }
    
    /**
     * Parses arguments in the context of the open command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareOpen(String args) {
        return new OpenCommand(args.trim());
    }
    
    /**
     * Parses arguments in the context of the save command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSave(String args) {
        return new SaveCommand(args.trim());
    }

    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }
    
    private Command prepareFindTag(String args) {
        final Matcher matcher = Pattern.compile(Tag.TAG_VALIDATION_REGEX).matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindTagCommand.MESSAGE_USAGE));
        }
        
        return new FindTagCommand(args);
    }

    

	/**
     * Parses arguments in the context of the list command.
     *
     * @param args full command args string
     * @return the prepared command
     */    
	private Command prepareList(String args) {

		if (args.contains("task")) {
			return new ListCommand("task");
		}

		if (args.contains("activit")) {
			return new ListCommand("activity");
		}

		if (args.contains("event")) {
			return new ListCommand("event");
		}

	      if (args.contains("done")) {
	            return new ListCommand("done");
	        }
          if (args.contains("all")) {
              return new ListCommand("all");
          }

		
		if (args.equals("")) {
			return new ListCommand("");
		} else {
			return new IncorrectCommand(ListCommand.MESSAGE_INVALID_LIST_TYPE);
		}

	}

    
}
```
###### \java\seedu\lifekeeper\model\activity\Activity.java
``` java
    public boolean hasReminderPassed() {
        return reminder.isBeforeNow();
    }

    /**
     * Replaces this activity's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    @Override
    public boolean equals(Object other) {
        if (this == null || other == null) {
            return !(this == null ^ other == null);
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            return other == this // short circuit if same object
                    || (other instanceof ReadOnlyActivity // instanceof handles nulls
                    && this.isSameStateAs((ReadOnlyActivity) other));
        }
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, reminder, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public void setCompletionStatus(boolean isComplete) {
        this.isCompleted = isComplete;
        
    }

    @Override
    public String toStringCompletionStatus() {
        if(isCompleted) {
            return "Completed";
        } 
            return ""; 
    }

	@Override
	public boolean hasPassedDueDate() {
		return false;
	}
    
    public static Activity create (ReadOnlyActivity act) {
		
    	String actType = act.getClass().getSimpleName().toLowerCase();
    	
    			switch (actType) {
                
    			case "activity":
                    return new Activity(act);
                case "task":
                	 return new Task((ReadOnlyTask) act);
                case "event":
                	return new Event((ReadOnlyEvent) act);
    }
				return null;
    	
    }

    public boolean getisOver() {
        return false;
    }

}
```
###### \java\seedu\lifekeeper\model\activity\ActivityManager.java
``` java
public class ActivityManager {
    private static final String COMMAND_TYPE_UNDO = "undo";
    private static final String COMMAND_TYPE_EDIT = "edit";

    private static final String ENTRY_TYPE_EVENT = "event";
    private static final String ENTRY_TYPE_TASK = "task";
    private static final String ENTRY_TYPE_ACTIVITY = "activity";

    private static final String NULL_ENTRY = "";

    /**
     * Replaces the parameters in the old task to the new parameters specified.
     * 
     * @param oldTask
     *            the old task.
     * @param newParams
     *            the new parameters.
     * @param type
     *            "edit" to edit the old task, or "undo" to revert an edit.
     * @return the updated entry.
     */
    public static Activity editUnaffectedParams(Activity oldTask, Activity newParams, String type) {
        Activity newActivity = null;
        String oldTaskType = oldTask.getClass().getSimpleName().toLowerCase();
        String newParamsType = newParams.getClass().getSimpleName().toLowerCase();

        try {
            switch (oldTaskType) {
            case ENTRY_TYPE_ACTIVITY:
                if (newParamsType.equals(ENTRY_TYPE_TASK)) { // change from activity to task
                    newActivity = updateTask(oldTask, newParams, type, true);
                } else if (newParamsType.equals(ENTRY_TYPE_EVENT)) { // change from activity to event
                    newActivity = updateEvent(oldTask, newParams, type, true);
                } else { // remain as activity
                    newActivity = updateActivity(oldTask, newParams, type);
                }
                
                newActivity.setCompletionStatus(oldTask.getCompletionStatus());
                break;
            case ENTRY_TYPE_TASK:
                if (type.equals(COMMAND_TYPE_EDIT)) {
                    newActivity = updateTask((Task) oldTask, newParams, type, newParamsType.equals(ENTRY_TYPE_TASK));
                } else if (type.equals(COMMAND_TYPE_UNDO)) {
                    newActivity = updateActivity(oldTask, newParams, type);
                }

                newActivity.setCompletionStatus(oldTask.getCompletionStatus());
                break;
            case ENTRY_TYPE_EVENT:
                if (type.equals(COMMAND_TYPE_EDIT)) {
                    newActivity = updateEvent((Event) oldTask, newParams, type, newParamsType.equals(ENTRY_TYPE_EVENT));
                } else if (type.equals(COMMAND_TYPE_UNDO)) {
                    newActivity = updateActivity(oldTask, newParams, type);
                }
                
                break;
            default:
                assert false : "Invalid class type";
            }
        } catch (IllegalValueException ive) {
            assert false : "There should not be any illegal value at this point";
        }

        return newActivity;
    }

    /**
     * Returns an activity overwriting data from the old entry with the new parameters.
     * @param oldTask the old entry.
     * @param newParams the new parameters.
     * @param type "edit" to edit the old task, or "undo" to revert an edit.
     * @return the Activity containing the new parameters.
     * @throws IllegalValueException
     */
    private static Activity updateActivity(Activity oldTask, Activity newParams, String type)
            throws IllegalValueException {
        return new Activity(
                updateTaskName(oldTask, newParams, type), 
                updateReminder(oldTask, newParams, type),
                updateTags(oldTask, newParams, type));
    }

    /**
     * Returns a task overwriting data from the old entry with the new parameters.
     * @param oldTask the old entry.
     * @param newParams the new parameters.
     * @param type "edit" to edit the old task, or "undo" to revert an edit.
     * @param isNewParamsATask true if the new parameters is of type Task (has a due date and/or priority). 
     * @return the Task containing the new parameters.
     * @throws IllegalValueException
     */
    private static Task updateTask(Activity oldTask, Activity newParams, String type, boolean isNewParamsATask)
            throws IllegalValueException {
        if (isNewParamsATask) {
            return new Task(
                    updateTaskName(oldTask, newParams, type), 
                    updateDueDate(oldTask, newParams, type),
                    updatePriority(oldTask, newParams, type), 
                    updateReminder(oldTask, newParams, type),
                    updateTags(oldTask, newParams, type));
        } else {
            return new Task(
                    updateTaskName(oldTask, newParams, type),
                    new DueDate(((Task) oldTask).getDueDate().getCalendarValue()),
                    new Priority(((Task) oldTask).getPriority().toString()), 
                    updateReminder(oldTask, newParams, type),
                    updateTags(oldTask, newParams, type));
        }
    }

    /**
     * Returns an event overwriting data from the old entry with the new parameters.
     * @param oldTask the old entry.
     * @param newParams the new parameters.
     * @param type "edit" to edit the old task, or "undo" to revert an edit.
     * @param isNewParamsATask true if the new parameters is of type Event (has start and end time). 
     * @return the Event containing the new parameters.
     * @throws IllegalValueException
     */
    private static Event updateEvent(Activity oldTask, Activity newParams, String type, boolean isNewParamsAnEvent)
            throws IllegalValueException {
        if (isNewParamsAnEvent) {
            return new Event(
                    updateTaskName(oldTask, newParams, type), 
                    updateStartTime(oldTask, newParams, type),
                    updateEndTime(oldTask, newParams, type), 
                    updateReminder(oldTask, newParams, type),
                    updateTags(oldTask, newParams, type));
        } else {
            return new Event(
                    updateTaskName(oldTask, newParams, type),
                    new StartTime(((Event) oldTask).getStartTime().getCalendarValue(),
                            ((Event) oldTask).getStartTime().recurring,
                            ((Event) oldTask).getStartTime().RecurringMessage),
                    new EndTime(((Event) oldTask).getEndTime().getCalendarValue(),
                            ((Event) oldTask).getStartTime().recurring,
                            ((Event) oldTask).getStartTime().RecurringMessage),
                    updateReminder(oldTask, newParams, type), 
                    updateTags(oldTask, newParams, type));
        }
    }

```
###### \java\seedu\lifekeeper\model\activity\ActivityManager.java
``` java
    private static Name updateTaskName(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        if (newParams.getName().toString().equals(NULL_ENTRY) && type.equals(COMMAND_TYPE_EDIT)) {
            return new Name(oldTask.getName().toString());
        } else {
            return new Name(newParams.getName().toString());
        }
    }
    
    private static Reminder updateReminder(Activity oldTask, Activity newParams, String type)
            throws IllegalValueException {
        Reminder newReminder;

        if (newParams.getReminder().toString().equals(NULL_ENTRY) && type.equals(COMMAND_TYPE_EDIT)) {
            newReminder = new Reminder(oldTask.getReminder().getCalendarValue());
            newReminder.recurring = oldTask.getReminder().recurring;
            newReminder.recurringMessage = oldTask.getReminder().recurringMessage;
        } else {
            newReminder = new Reminder(newParams.getReminder().getCalendarValue());
            newReminder.recurring = newParams.getReminder().recurring;
            newReminder.recurringMessage = newParams.getReminder().recurringMessage;
        }

        return newReminder;
    }

    private static DueDate updateDueDate(Activity oldTask, Activity newParams, String type)
            throws IllegalValueException {
        if (!newParams.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_TASK)
                || (((Task) newParams).getDueDate().toString().equals(NULL_ENTRY) 
                        && type.equals(COMMAND_TYPE_EDIT)
                        && oldTask.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_TASK))) {
            return new DueDate(((Task) oldTask).getDueDate().getCalendarValue());
        } else if (((Task) newParams).getDueDate().toString().equals(NULL_ENTRY) 
                && type.equals(COMMAND_TYPE_EDIT)
                && oldTask.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_ACTIVITY)) {
            return new DueDate("");
        } else {
            return new DueDate(((Task) newParams).getDueDate().getCalendarValue());
        }
    }

    private static Priority updatePriority(Activity oldTask, Activity newParams, String type)
            throws IllegalValueException {
        Priority newPriority;

        if (!newParams.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_TASK)) {
            return new Priority(((Task) oldTask).getPriority().toString());
        }

        if (((Task) newParams).getPriority().toString().equals(NULL_ENTRY) && type.equals(COMMAND_TYPE_EDIT)) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_ACTIVITY)) {
                newPriority = new Priority("0");
            } else {
                newPriority = new Priority(((Task) oldTask).getPriority().toString());
            }
        } else {
            newPriority = new Priority(((Task) newParams).getPriority().toString());
        }

        return newPriority;
    }

    private static StartTime updateStartTime(Activity oldTask, Activity newParams, String type)
            throws IllegalValueException {
        StartTime newStartTime;

        if (!newParams.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_EVENT)) {
            return new StartTime(((Event) oldTask).getStartTime().getCalendarValue());
        }

        if (((Event) newParams).getStartTime().toString().equals(NULL_ENTRY) && type.equals(COMMAND_TYPE_EDIT)) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_ACTIVITY)) {
                newStartTime = new StartTime("");
            } else {
                newStartTime = new StartTime(((Event) oldTask).getStartTime().getCalendarValue());
                newStartTime.recurring = ((Event) oldTask).getStartTime().recurring;
                newStartTime.RecurringMessage = ((Event) oldTask).getStartTime().RecurringMessage;

            }
        } else {
            newStartTime = new StartTime(((Event) newParams).getStartTime().getCalendarValue());
            newStartTime.recurring = ((Event) newParams).getStartTime().recurring;
            newStartTime.RecurringMessage = ((Event) newParams).getStartTime().RecurringMessage;
        }

        return newStartTime;
    }

    private static EndTime updateEndTime(Activity oldTask, Activity newParams, String type)
            throws IllegalValueException {
        EndTime newEndTime;

        if (!newParams.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_EVENT)) {
            return new EndTime(((Event) oldTask).getEndTime().getCalendarValue());
        }

        if (((Event) newParams).getEndTime().toString().equals(NULL_ENTRY) && type.equals(COMMAND_TYPE_EDIT)) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase(ENTRY_TYPE_ACTIVITY)) {
                newEndTime = new EndTime(((Event) oldTask).getStartTime(), "");
            } else {
                newEndTime = new EndTime(((Event) oldTask).getEndTime().getCalendarValue());
                newEndTime.recurring = ((Event) oldTask).getEndTime().recurring;
                newEndTime.RecurringMessage = ((Event) oldTask).getEndTime().RecurringMessage;
            }
        } else {
            newEndTime = new EndTime(((Event) newParams).getEndTime().getCalendarValue());
            newEndTime.recurring = ((Event) newParams).getEndTime().recurring;
            newEndTime.RecurringMessage = ((Event) newParams).getEndTime().RecurringMessage;
        }

        return newEndTime;
    }

    private static UniqueTagList updateTags(Activity oldTask, Activity newParams, String type) {
        UniqueTagList newTags;
        if (type.equals(COMMAND_TYPE_EDIT)) {
            newTags = new UniqueTagList(oldTask.getTags());
        } else {
            newTags = new UniqueTagList();
        }

        for (Tag toAdd : newParams.getTags()) {
            try {
                newTags.add(toAdd);
            } catch (DuplicateTagException e) {
                continue; //ignore dupliate tags
            }
        }

        return newTags;
    }

}
```
###### \java\seedu\lifekeeper\model\activity\DateTime.java
``` java
public abstract class DateTime implements Comparable<DateTime>{
    public Calendar value;
    protected static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("EEE, MMM d, yyyy h:mm a");
    protected static final SimpleDateFormat SAVE_DATE_FORMAT = new SimpleDateFormat("d-MM-yyyy h:mm aa");
    protected static final DateUtil DATE_PARSER = new DateUtil();
    public boolean recurring;

    public DateTime(Calendar date) {
        if (date == null) {
            this.value = null;
        } else {
            this.value = Calendar.getInstance();
            this.value.setTime(date.getTime());
        }
    }

    public DateTime(String date) throws IllegalValueException {
        assert date != null;

        if (date.equals("")) {
            this.value = null;
        } else {
            this.value = Calendar.getInstance();
            this.value.set(Calendar.MILLISECOND, 0);
            this.value.set(Calendar.SECOND, 0);
        }
    }
    
```
###### \java\seedu\lifekeeper\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is before the current time.
     */
    public boolean isBeforeNow() {
        Date now = Calendar.getInstance().getTime();
        return this.value.getTime().before(now);
    }
    
```
###### \java\seedu\lifekeeper\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is after the current time.
     */
    public boolean isAfterNow() {
        Date now = Calendar.getInstance().getTime();
        return this.value.getTime().after(now);
    }
    
```
###### \java\seedu\lifekeeper\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is before the date in the specified DateTime object.
     */
    public boolean isBefore(DateTime other) {
        Date otherDate = other.getCalendarValue().getTime();
        return this.value.getTime().before(otherDate);
    }
    
```
###### \java\seedu\lifekeeper\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is after the date in the specified DateTime object.
     */
    public boolean isAfter(DateTime other) {
        Date otherDate = Calendar.getInstance().getTime();
        return this.value.getTime().after(otherDate);
    }
    
    /**
     * Comparator for DateTime. Earlier dates are ordered before later dates.
     */
    @Override
    public int compareTo(DateTime other) {
        return this.value.getTime().compareTo(other.value.getTime());
    }



    public Calendar getCalendarValue() {
        return this.value;
    }
    
    @Override
    public String toString() {
        if (this.value == null) {
            return "";
        } else {
            return DATE_FORMAT.format(value.getTime());
        }
    }


    public String toSave() {
        if (this.value == null) {
            return new String("");
        } else {
            return SAVE_DATE_FORMAT.format(value.getTime());
        }
    }
    
    @Override
    public boolean equals(Object other) {
        if (value == null || ((DateTime) other).value == null) {
            return !((value == null) ^ ((DateTime) other).value == null);
        } else {
            return other == this // short circuit if same object
                    || (other instanceof DateTime // instanceof handles nulls
                            && (this.value.equals(((DateTime) other).value))
                            && this.recurring == ((DateTime) other).recurring); // state
                                                                             // check
        }
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### \java\seedu\lifekeeper\model\activity\event\ReadOnlyEvent.java
``` java
public interface ReadOnlyEvent extends ReadOnlyActivity {
    StartTime getStartTime();
    EndTime getEndTime();
    
    boolean isOngoing();
    boolean isOver();

    String toStringCompletionStatus();
    
    String displayTiming();
    
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyEvent other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getStartTime().equals(this.getStartTime())
                && other.getEndTime().equals(this.getEndTime())
                && other.getReminder().equals(this.getReminder()));
    }
    
    /**
     * Formats the activity as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
                .append(" Start Time: ")
                .append(getStartTime())
                .append(" End Time: ")
                .append(getEndTime())
                .append(" Reminder: ")
                .append(getReminder())
                .append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

}
```
###### \java\seedu\lifekeeper\model\activity\task\ReadOnlyTask.java
``` java
public interface ReadOnlyTask extends ReadOnlyActivity {

    DueDate getDueDate();
    Priority getPriority();
    boolean getCompletionStatus();
    boolean isDueDateApproaching();
    boolean hasPassedDueDate();
    
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getDueDate().equals(this.getDueDate())
                && other.getPriority().equals(this.getPriority())
                && other.getReminder().equals(this.getReminder()));
    }
    
    /**
     * Formats the activity as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
                .append(" Duedate: ")
                .append(getDueDate())
                .append(" Priority: ")
                .append(getPriority())
                .append(" Reminder: ")
                .append(getReminder())
                .append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

    String toStringCompletionStatus();
}
```
###### \java\seedu\lifekeeper\model\activity\UniqueActivityList.java
``` java
    /**
     * Edits the equivalent Task from the list.
     *
     * @throws TaskNotFoundException if no such activity could be found in the list.
     */
    public void edit(Activity task, Activity newTask) throws TaskNotFoundException, DuplicateTaskException {
        assert task != null;
        assert newTask != null;
        
        if (contains(newTask) && (task.getTags().equals(newTask.getTags()))) {
            throw new DuplicateTaskException();
        }
        
        int index = internalList.indexOf(task);
        if(index == -1) {
            throw new TaskNotFoundException();
        }

        internalList.set(index, newTask);
    }
    
```
###### \java\seedu\lifekeeper\model\activity\UniqueActivityList.java
``` java
    public void mark(Activity task, boolean isComplete) throws TaskNotFoundException {
        int index = internalList.indexOf(task);
        
        if (index == -1) {
            throw new TaskNotFoundException();
        }
        
        ActivityManager.markTask(task, isComplete);
        
        internalList.set(index, task);
    }
    
    public ObservableList<Activity> getInternalList() {
        return internalList;
    }

    /**
     * Returns task if the list contains an equivalent task as the given argument.
     */
    public Activity get(Activity toGet) {
        assert toGet != null;
        return internalList.get(internalList.indexOf(toGet));
    }

    @Override
    public Iterator<Activity> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueActivityList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueActivityList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }


}
```
###### \java\seedu\lifekeeper\model\activity\UpcomingReminders.java
``` java
/**
 * Keeps a queue of upcoming events. Events that are ongoing or over will not be
 * added to the queue. 
 * The queue is ordered in such a way that the earliest incoming reminder is at the front of the queue. 
 */
public class UpcomingReminders {

    private static final int DEFAULT_SIZE = 50;

    private static PriorityQueue<ReadOnlyActivity> reminderQueue;
    
    private static final Logger logger = LogsCenter.getLogger(LogsCenter.class);

    {
        reminderQueue = new PriorityQueue<>(DEFAULT_SIZE, new Comparator<ReadOnlyActivity>() {
            
            public int compare(ReadOnlyActivity first, ReadOnlyActivity second) {
                return first.getReminder().compareTo(second.getReminder());
            }
        });
    }

    public UpcomingReminders() {}
    
    /**
     * Empties the current event queue and adds the specified activities into the queue. 
     * @param activities to be added into the queue
     */
    public void initialize(Collection<Activity> activities) {
        empty();
        
        for (ReadOnlyActivity activity : activities) {
            if (activity.getReminder().getCalendarValue() != null && !activity.hasReminderPassed()) {
                logger.info("Activity added to reminder queue: " + activity.toString());
                reminderQueue.add(activity);
            }
        }
    }

    /**
     * Adds an activity to the reminder queue. Activities without reminder or a
     * passed reminder will not be added.
     * 
     * @return true if the activity is added to the queue.
     */
    public boolean addReminder(ReadOnlyActivity newActivity) {
        if (newActivity.getReminder().getCalendarValue() != null && !newActivity.hasReminderPassed()) {
            return reminderQueue.add(newActivity);
        } else {
            return false;
        }
    }

    /**
     * Removes the activity from the reminder queue, if it exists.
     * 
     * @return true if the reminder is successfully removed.
     */
    public boolean removeReminder(ReadOnlyActivity activity) {
        return reminderQueue.remove(activity);
    }

    /**
     * Dequeues and returns a list of events having reminders closest to the current time.
     * 
     * @return a list of the events with start time closest to current time.
     */
    public static ArrayList<ReadOnlyActivity> popNextReminders() {
        ArrayList<ReadOnlyActivity> nextRemindedActivities = new ArrayList<>();

        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.SECOND, 10);
        Date offset10Secs = cal.getTime(); //The current time is offset by 10 seconds to account for lag.

        while (!reminderQueue.isEmpty()
                && reminderQueue.peek().getReminder().getCalendarValue().getTime().before(offset10Secs)) {
            ReadOnlyActivity toBeReminded = reminderQueue.poll();
            logger.info("Activity removed from reminder queue: " + toBeReminded.toString());
            nextRemindedActivities.add(toBeReminded);
            toBeReminded.getReminder().resetTime();
        }
        
        return nextRemindedActivities;
    }
    
    /**
     * Clears the reminder queue.
     */
    public static void empty() {
        while (!reminderQueue.isEmpty()) {
            reminderQueue.poll();
        }
    }
}
```
###### \java\seedu\lifekeeper\model\LifeKeeper.java
``` java
    public Activity editTask(Activity task, Activity newParams, String type) throws TaskNotFoundException, DuplicateTaskException {
            if (activities.contains(task)) {
                Activity newTask = ActivityManager.editUnaffectedParams(task, newParams, type);
                activities.edit(task, newTask);
                nextReminders.removeReminder(task);
                nextReminders.addReminder(newTask);
                
                return newTask;
            } else {
                throw new UniqueActivityList.TaskNotFoundException();
            }
    }

	public void markTask(Activity task, boolean isComplete) throws TaskNotFoundException {
        if (activities.contains(task)) {
            activities.mark(task, isComplete);
        } else {
            throw new UniqueActivityList.TaskNotFoundException();
        }
	}
    
//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return activities.getInternalList().size() + " persons, " + tags.getInternalList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyActivity> getActivityList() {
        return Collections.unmodifiableList(activities.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueActivityList getUniqueActivityList() {
        return this.activities;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof LifeKeeper // instanceof handles nulls
                && this.activities.equals(((LifeKeeper) other).activities)
                && this.tags.equals(((LifeKeeper) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(activities, tags);
    }



}
```
###### \java\seedu\lifekeeper\model\ModelManager.java
``` java
    @Override
    public synchronized Activity editTask(Activity oldTask, Activity newParams) throws TaskNotFoundException, DuplicateTaskException {
        Activity editedTask = lifeKeeper.editTask(oldTask, newParams, "edit");
        indicateAddressBookChanged();
        
        return editedTask;
    }
    
    @Override
    public synchronized Activity undoEditTask(Activity oldTask, Activity newParams) throws TaskNotFoundException, DuplicateTaskException {
        Activity editedTask = lifeKeeper.editTask(oldTask, newParams, "undo");
        indicateAddressBookChanged();
        
        return editedTask;
    }

	@Override
	public synchronized void markTask(Activity taskToMark, boolean isComplete) throws TaskNotFoundException {
		lifeKeeper.markTask(taskToMark, isComplete);
        updateFilteredListToShowAll();
        indicateAddressBookChanged();
		
	}
	
	@Subscribe
	public void indicateSaveLocChanged(SaveEvent event) {
	    indicateAddressBookChanged();
	}
    
    //=========== Filtered Activity List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyActivity> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredActivities);
    }
    
    @Override
    public UnmodifiableObservableList<Activity> getFilteredTaskListForEditing() {
        return new UnmodifiableObservableList<>(filteredActivities);
    }
    
```
###### \java\seedu\lifekeeper\storage\XmlLifekeeperStorage.java
``` java
    /**
     * Sets the storage location of the activity data to the new file path specified
     * @param filePath
     */
    public static void setAddressBookFilePath(String filePath){
        XmlLifekeeperStorage.filePath = filePath;
    }

    public String getAddressBookFilePath() {
        return filePath;
    }
    
    public static String getFilePathForSaveCommand() {
        return filePath;
    }

    /**
     * Similar to {@link #readAddressBook()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyLifeKeeper> readAddressBook(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File addressBookFile = new File(filePath);

        if (!addressBookFile.exists()) {
            logger.info("AddressBook file "  + addressBookFile + " not found");
            return Optional.empty();
        }

        ReadOnlyLifeKeeper addressBookOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(addressBookOptional);
    }

    /**
     * Similar to {@link #saveAddressBook(ReadOnlyLifeKeeper)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveAddressBook(ReadOnlyLifeKeeper lifeKeeper, String filePath) throws IOException {
        assert lifeKeeper != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableLifekeeper(lifeKeeper));
    }

    @Override
    public Optional<ReadOnlyLifeKeeper> readAddressBook() throws DataConversionException, IOException {
        return readAddressBook(filePath);
    }

    @Override
    public void saveAddressBook(ReadOnlyLifeKeeper lifeKeeper) throws IOException {
        saveAddressBook(lifeKeeper, filePath);
    }
    
    public static boolean checkIfDataFileExists(String filePath) {
        File file = new File(filePath);
        return file.exists();
    }
}
```
###### \java\seedu\lifekeeper\ui\ActivityCard.java
``` java
    /**
     * Styles the status text and the card background to the color specified.
     * 
     * @param color
     *            the color to be chosen as the style of the card.
     */
    private void setCssStyle(String color) {
        switch (color.toLowerCase()) {
        case "red":
            completion.setStyle(COMPLETION_STYLE_RED + DEFAULT_COMPLETION_FONT);
            cardPane.setStyle(CARDPANE_STYLE_RED);
            break;
        case "yellow":
            completion.setStyle(COMPLETION_STYLE_YELLOW + DEFAULT_COMPLETION_FONT);
            cardPane.setStyle(CARDPANE_STYLE_YELLOW);
            break;
        case "green":
            completion.setStyle(COMPLETION_STYLE_GREEN + DEFAULT_COMPLETION_FONT);
            cardPane.setStyle(CARDPANE_STYLE_GREEN);
            break;
        case "blue":
            completion.setStyle(COMPLETION_STYLE_BLUE + DEFAULT_COMPLETION_FONT);
            cardPane.setStyle(CARDPANE_STYLE_BLUE);
            break;
        }
    }
}
```
###### \java\seedu\lifekeeper\ui\MainWindow.java
``` java
    @FXML
    public void handleSaveLoc() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setCurrentDirectory(new File(userPrefs.getDataFilePath()));
        fileChooser.setFileFilter(new FileNameExtensionFilter("XML File", "xml"));
        fileChooser.setAcceptAllFileFilterUsed(false);
        int result = fileChooser.showSaveDialog(null);
        
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            
            if (!selectedFile.getAbsolutePath().endsWith(".xml")) {
                selectedFile = new File(selectedFile.getAbsolutePath() + ".xml");
            }
            
            setSaveLocation(selectedFile.getAbsolutePath());
        }
    }
    
```
###### \java\seedu\lifekeeper\ui\MainWindow.java
``` java
    public void handleOpen() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setCurrentDirectory(new File(userPrefs.getDataFilePath()));
        fileChooser.setFileFilter(new FileNameExtensionFilter("XML File", "xml"));
        fileChooser.setAcceptAllFileFilterUsed(false);
        int result = fileChooser.showOpenDialog(null);
        
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            
            if (!selectedFile.getAbsolutePath().endsWith(".xml")) {
                selectedFile = new File(selectedFile.getAbsolutePath() + ".xml");
            }
            
            openFile(selectedFile);
        }
    }
    
```
###### \java\seedu\lifekeeper\ui\MainWindow.java
``` java
    public void setSaveLocation(String filePath) {
        resultDisplay.postMessage("New save location: " + filePath);
        changeFileLocation(filePath);
        
        EventsCenter.getInstance().post(new SaveEvent());
    }
    
```
###### \java\seedu\lifekeeper\ui\MainWindow.java
``` java
    public void openFile(File selectedFile) {
        if (!selectedFile.exists()) {
            resultDisplay.postMessage("The specified file doesn't exist");
        } else {
            EventsCenter.getInstance().post(new LoadLifekeeperEvent(selectedFile, logic));
            resultDisplay.postMessage("Loaded data from file: " + selectedFile.getAbsolutePath());
        }
    }
    
```
###### \java\seedu\lifekeeper\ui\MainWindow.java
``` java
    public void changeFileLocation(String filePath) {
        XmlLifekeeperStorage.setAddressBookFilePath(filePath);
        userPrefs.setDataFilePath(filePath);
        statusBarFooter.setSaveLocation(filePath);
    }

    public ActivityListPanel getActivityListPanel() {
        return this.activityListPanel;
    }
    
    public void refreshActivityListPanel() {
        activityListPanel.refresh();
    }
    
    public void refreshOverdueListPanel() {
        overdueListPanel.refresh(logic);
    }

}
```
###### \java\seedu\lifekeeper\ui\UiManager.java
``` java
    private void showReminderDialog(ArrayList<ReadOnlyActivity> activities) {
        ImageIcon reminderIcon = new ImageIcon(getClass().getResource("/images/ringing.png"),
                "Reminder Bell");
        
        for (ReadOnlyActivity activity : activities) {
            JOptionPane.showMessageDialog(new JFrame(),
                    textForReminderDialog(activity, activity.getClass().getSimpleName()),
                    "Reminder: " + activity.getName().toString(),
                    JOptionPane.INFORMATION_MESSAGE,
                    reminderIcon);
        }
    }
    
```
###### \java\seedu\lifekeeper\ui\UiManager.java
``` java
    private String textForReminderDialog(ReadOnlyActivity activity, String type) {
        final StringBuilder sb = new StringBuilder();
        
        sb.append("Reminder for the " + type.toLowerCase() + ": " +  activity.getName());
        
        switch (type) {
        case "Task":
            if (((Task) activity).getDueDate().getCalendarValue() != null) {
                sb.append("\nDue:       " + ((Task) activity).getDueDate().toString());
            }
            sb.append("\nPriority: " + ((Task) activity).getPriority().forReminderDialog());
            break;
        case "Event":
            sb.append("\nTime: " + ((Event) activity).getStartTime().toString()
                    + "\nto        " + ((Event) activity).getEndTime().toString());
            break;
        }
        
        return sb.toString();
    }

    //==================== Event Handling Code =================================================================

    @Subscribe
    private void handleDataSavingExceptionEvent(DataSavingExceptionEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showFileOperationAlertAndWait("Could not save data", "Could not save data to file", event.exception);
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }
    
    @Subscribe
    private void handleSaveEvent(SaveFileChooserEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        
        if (event.saveDirectory.equals("")) {
            mainWindow.handleSaveLoc();
        } else {
            mainWindow.setSaveLocation(event.saveDirectory);
        }
    }
    
    @Subscribe
    private void handleOpenEvent(OpenFileChooserEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        
        if (event.fileDirectory.equals("")) {
            mainWindow.handleOpen();
        } else {
            mainWindow.openFile(new File(event.fileDirectory));
        }
    }

    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getActivityListPanel().scrollTo(event.targetIndex);
    }
    
    @Subscribe
    private void handleDirectoryChangedEvent(FileDirectoryChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.changeFileLocation(event.filePath);
    }
    
    //==================== Refresh Handling Code =================================================================
    
```
###### \java\seedu\lifekeeper\ui\UiManager.java
``` java
    /**
     * Methods to invoke refreshing every minute
     */
    private void initRefresh() {
        initActivityRefresh();
        initOverdueRefresh();
        initReminderRefresh();
    }
    
    private void initActivityRefresh() {
        refreshTimer.cancel();
        refreshTimer = new Timer("Refresh");
        
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        
        refreshTimer.scheduleAtFixedRate(new TimerTask() {
            public void run() {
                mainWindow.refreshActivityListPanel();
            }
        }, cal.getTime(), DELAY);
    }
    
    private void initOverdueRefresh() {
        overdueTimer.cancel();
        overdueTimer = new Timer("Overdue");
        
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        cal.add(Calendar.SECOND, 1);
        
        overdueTimer.scheduleAtFixedRate(new TimerTask() {
            public void run() {
                mainWindow.refreshOverdueListPanel();
            }
        }, cal.getTime(), DELAY);
    }
    
    private void initReminderRefresh() {
        reminderTimer.cancel();
        reminderTimer = new Timer("Reminder");
        
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        cal.add(Calendar.SECOND, 2);
        
        reminderTimer.scheduleAtFixedRate(new TimerTask() {
            public void run() {
                Platform.runLater(new Runnable() {
                    public void run() {
                        showReminderDialog(UpcomingReminders.popNextReminders());
                    }
                });
            }
        }, cal.getTime(), DELAY);
    }
}
```
###### \resources\view\MainWindow.fxml
``` fxml
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleOpen" text="Open" />
               </items>
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleSaveLoc" text="Save" />
               </items>
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.85" prefWidth="653.0" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="activityListPanelPlaceholder" prefHeight="580.0" prefWidth="522.0" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
            <VBox fx:id="dashboardDisplay" alignment="TOP_CENTER" minWidth="140.0" prefHeight="600.0" prefWidth="150.0">
               <children>
                  <Label maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" prefHeight="20.0" prefWidth="141.0" styleClass="tooltip-text" text="Overdue Tasks">
                     <padding>
                        <Insets left="30.0" />
                     </padding>
                     <VBox.margin>
                        <Insets />
                     </VBox.margin>
                     <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                     </stylesheets></Label>
                  <AnchorPane fx:id="overdueListDisplayPlaceHolder" maxHeight="1.7976931348623157E308" maxWidth="-Infinity" minHeight="-Infinity" minWidth="120.0" prefHeight="539.0" prefWidth="231.0" VBox.vgrow="ALWAYS" />
                  <VBox fx:id="overdueTaskList" alignment="TOP_RIGHT" maxHeight="-Infinity" maxWidth="-Infinity" minWidth="90.0" prefHeight="540.0" prefWidth="180.0" VBox.vgrow="ALWAYS">
                     <padding>
                        <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                     </padding>
                  </VBox>
               </children>
               <padding>
                  <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
               </padding>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
