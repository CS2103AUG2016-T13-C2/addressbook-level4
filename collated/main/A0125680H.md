# A0125680H
###### \java\seedu\address\commons\util\DateUtil.java
``` java
    /**
     * Validate date format with regular expression
     * 
     * @param date
     * @return true valid date format, false invalid date format
     * 
     */
    public static boolean validate(String date) {
        Date validDate;

        for (SimpleDateFormat sdf : DATE_FORMATS) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return true;
                }
            } catch (ParseException e) {
                continue;
            }
        }
        for (SimpleDateFormat sdf : DATE_FORMATS1) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return true;
                }
            } catch (ParseException e) {
                continue;
            }
        }

        return false;
    }

    /**
     * Convert valid reminder date input into date format Optional to contain
     * time of the day in hour and mins
     * 
     * @param date
     * @return the date in valid date format
     * @throws IllegalValueException
     */
```
###### \java\seedu\address\commons\util\DateUtil.java
``` java
    /**
     * Checks whether the format entered will be accepted by LifeKeeper
     * 
     * @param format
     * @return boolean indicating whether format is accepted.
     */
    public boolean isValidFormat(String format) {
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        for (SimpleDateFormat a : DATE_FORMATS) {
            if (a.equals(formatter)) {
                return true;
            }
        }
        return false;
    }
    /*
     * public static String everyMonth(String date) throws IllegalValueException
     * { String[] recurday = date.split(" ", 2); String day = recurday[0];
     * String months = ""; Calendar cal = Calendar.getInstance(); if
     * (recurday.length != 1) { int month = cal.get(Calendar.MONTH); if (month <
     * 10) months = "0" + month; else months = "" + month; int year =
     * cal.get(Calendar.YEAR); day = day.concat("-" + months + "-" + year + " "
     * + recurday[1]); } else throw new IllegalValueException(INVALID_TIME);
     * return day; }
     * 
     * public static String everyYear(String date) throws IllegalValueException
     * { String[] recurday = date.split(" ", 2); if (recurday.length == 1) throw
     * new IllegalValueException(INVALID_TIME); String day = recurday[0];
     * Calendar cal = Calendar.getInstance(); int year = cal.get(Calendar.YEAR);
     * day = day.concat("-" + year + " " + recurday[1]); return day; }
     */

    public static boolean recurValidDate(String date) {
        Date validDate;

        for (SimpleDateFormat sdf : TIME_FORMATS) {
            try {
                validDate = sdf.parse(date);
                if (date.equals(sdf.format(validDate))) {
                    return true;
                }
            } catch (ParseException e) {
                continue;
            }
        }
        return false;
    }
}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the indexed task from Lifekeeper. \n"
            + "Parameters: INDEX (must be a positive integer) [n/TASK_NAME] [c/CATEGORY] [d/DEADLINE] p/PRIORITY_LEVEL r/REMINDER [t/TAG]...\n"
            + "Example: " + COMMAND_WORD + " 1 n/CS2103 T8A2 d/15-10-2016 p/3 r/12-01-2016 t/CS t/project";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task from: %1$s\nto: %2$s";
    public static final String MESSAGE_TASK_EXISTS = "An existing task already contains the specified parameters.";
    public static final String MESSAGE_ACTIVITY_MISMATCH = "Task cannot be changed to event and vice versa.";

    public final int targetIndex;
    
    private final String newParamsType;
    
    public final Activity newParams;

    /**
     * Set parameters to null if they are not provided.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public EditCommand(int targetIndex, String name, String duedate, String priority, String start, String end, String reminder, Set<String> tags)
            throws IllegalValueException {
        this.targetIndex = targetIndex;
        
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        newParamsType = identifyActivityType(duedate, priority, start, end);
        
        if (newParamsType.equalsIgnoreCase("float")) {
            this.newParams = new Activity(
                    new Name(name),
                    new Reminder(reminder),
                    new UniqueTagList(tagSet)
            );
        } else if (newParamsType.equalsIgnoreCase("task")) {
            this.newParams = new Task(
                    new Name(name),
                    new DueDate(duedate),
                    new Priority(priority),
                    new Reminder(reminder),
                    new UniqueTagList(tagSet)
            );
        } else if (newParamsType.equalsIgnoreCase("event")) {
            this.newParams = new Event(
                    new Name(name),
                    new StartTime(start),
                    new EndTime(new StartTime(start), end),
                    new Reminder(reminder),
                    new UniqueTagList(tagSet)
            );
        } else {
            assert false : "Invalid method output: identifyActivityType";
            throw new IllegalValueException(MESSAGE_INVALID_ACTIVITY_TYPE);
        }
        
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<Activity> lastShownList = model.getFilteredTaskListForEditing();

        Activity taskToEdit = lastShownList.get(targetIndex - 1);
        String taskToEditType = taskToEdit.getClass().getSimpleName();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        if (taskToEditType.equalsIgnoreCase("task") && newParamsType.equalsIgnoreCase("event")
                || taskToEditType.equalsIgnoreCase("event") && newParamsType.equalsIgnoreCase("task")) {
            return new CommandResult(MESSAGE_ACTIVITY_MISMATCH);
        }

        try {
            Activity oldTask = new Activity(taskToEdit);
            Activity editedTask = model.editTask(taskToEdit, newParams);

            PreviousCommand editCommand = new PreviousCommand(COMMAND_WORD, oldTask, editedTask);
            PreviousCommandsStack.push(editCommand);

            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, oldTask, editedTask));
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task to be edited cannot be missing";
            return new CommandResult("");
        } catch (DuplicateTaskException dte) {
            return new CommandResult(MESSAGE_TASK_EXISTS);
        }
    }

}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the edit activity command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args){
        final Matcher matcherEdit = PERSON_EDIT_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if(!matcherEdit.matches()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        String indexString = matcherEdit.group("targetIndex");
        Optional<Integer> index = parseIndex(indexString);
        
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        String params = " ".concat(matcherEdit.group("parameters").trim());
        final Matcher matcherParams = PERSON_EDIT_PARAMETERS_ARGS_FORMAT.matcher(params);
        
        if(!matcherParams.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        try {
            return new EditCommand(index.get(), 
                    getElement(matcherParams.group("task"), " n/"),
                    getElement(matcherParams.group("duedate")," d/"),
                    getElement(matcherParams.group("priority")," p/"),
                    getElement(matcherParams.group("start")," s/"),
                    getElement(matcherParams.group("end")," e/"),
                    getElement(matcherParams.group("reminder")," r/"),
                    getTagsFromArgs(matcherParams.group("tagArguments"))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSelect(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }

    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    

	/**
     * Parses arguments in the context of the list command.
     *
     * @param args full command args string
     * @return the prepared command
     */    
	private Command prepareList(String args) {

		if (args.contains("task")) {
			return new ListCommand("task");
		}

		if (args.contains("activit")) {
			return new ListCommand("activity");
		}

		if (args.contains("event")) {
			return new ListCommand("event");
		}

	      if (args.contains("done")) {
	            return new ListCommand("done");
	        }

		
		if (args.equals("")) {
			return new ListCommand("");
		} else {
			return new IncorrectCommand(ListCommand.MESSAGE_INVALID_LIST_TYPE);
		}

	}

    
}
```
###### \java\seedu\address\model\activity\Activity.java
``` java
    public boolean hasReminderPassed() {
        return reminder.isBeforeNow();
    }

    /**
     * Replaces this activity's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    @Override
    public boolean equals(Object other) {
        if (this == null || other == null) {
            return !(this == null ^ other == null);
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            return other == this // short circuit if same object
                    || (other instanceof ReadOnlyActivity // instanceof handles nulls
                    && this.isSameStateAs((ReadOnlyActivity) other));
        }
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, reminder, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public void setCompletionStatus(boolean isComplete) {
        this.isCompleted = isComplete;
        
    }

    @Override
    public String toStringCompletionStatus() {
        if(isCompleted) {
            return "Completed";
        } 
            return ""; 
    }

	@Override
	public boolean hasPassedDueDate() {
		return false;
	}
    
    public static Activity create (ReadOnlyActivity act) {
		
    	String actType = act.getClass().getSimpleName().toLowerCase();
    	
    			switch (actType) {
                
    			case "activity":
                    return new Activity(act);
                case "task":
                	 return new Task((ReadOnlyTask) act);
                case "event":
                	return new Event((ReadOnlyEvent) act);
    }
				return null;
    	
    }

    public boolean getisOver() {
        return false;
    }

}
```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
public class ActivityManager {
    private static final String NULL_ENTRY = "";
    
    public static Activity editUnaffectedParams(Activity oldTask, Activity newParams, String type) {
        Activity newActivity = null;
        String oldTaskType = oldTask.getClass().getSimpleName().toLowerCase();
        String newParamsType = newParams.getClass().getSimpleName().toLowerCase();
        try {
            switch (oldTaskType) {
            case "activity":
                if (newParamsType.equals("task")) { //change from activity to task
                    newActivity = new Task(
                            updateTaskName(oldTask, newParams, type),
                            updateDueDate(oldTask, newParams, type),
                            updatePriority(oldTask, newParams, type),
                            updateReminder(oldTask, newParams, type),
                            updateTags(oldTask, newParams)
                            );
                } else if (newParamsType.equals("event")) { //change from activity to event
                    newActivity = new Event(
                            updateTaskName(oldTask, newParams, type),
                            updateStartTime(oldTask, newParams, type),
                            updateEndTime(oldTask, newParams, type),
                            updateReminder(oldTask, newParams, type),
                            updateTags(oldTask, newParams)
                            );
                } else { //remain as activity
                    newActivity = new Activity(
                            updateTaskName(oldTask, newParams, type),
                            updateReminder(oldTask, newParams, type),
                            updateTags(oldTask, newParams)
                            );
                }
                
                newActivity.setCompletionStatus(oldTask.getCompletionStatus());
                break;
            case "task":
            	 if (newParamsType.equals("task")) {
            	 newActivity = new Task(
                         updateTaskName(oldTask, newParams, type),
                         updateDueDate((Task) oldTask, newParams, type),
                         updatePriority((Task) oldTask, newParams, type),
                         updateReminder(oldTask, newParams, type),
                         updateTags(oldTask, newParams)
                         );
            	 } else if (newParamsType.equals("activity") && type.equals("edit")) {
            	     newActivity = new Task(
            	             updateTaskName(oldTask, newParams, type),
            	             new DueDate(((Task) oldTask).getDueDate().getCalendarValue()),
            	             new Priority(((Task) oldTask).getPriority().toString()),
                             updateReminder(oldTask, newParams, type),
                             updateTags(oldTask, newParams)
            	             );
            	 } else if(type.equals("undo")) {
					newActivity = new Activity(
							updateTaskName(oldTask, newParams, type),
							updateReminder(oldTask, newParams, type),
							updateTags(oldTask, newParams)
					);
            		 
            	 }
            	
            	newActivity.setCompletionStatus(oldTask.getCompletionStatus());
                break;
            case "event":
                if (newParamsType.equals("event")) {
                    newActivity = new Event(
                            updateTaskName(oldTask, newParams, type),
                            updateStartTime((Event) oldTask, newParams, type),
                            updateEndTime((Event) oldTask, newParams, type),
                            updateReminder(oldTask, newParams, type),
                            updateTags(oldTask, newParams)
                            );
                    } else if (newParamsType.equals("activity") && type.equals("edit")) {
                        newActivity = new Event(
                                updateTaskName(oldTask, newParams, type),
                                new StartTime(((Event) oldTask).getStartTime().getCalendarValue()),
                                new EndTime(((Event) oldTask).getEndTime().getCalendarValue()),
                                updateReminder(oldTask, newParams, type),
                                updateTags(oldTask, newParams)
                                );
                    }
            	if (newParamsType.equals("activity") && (type.equals("undo")) ) {
                    newActivity = new Activity(
                            updateTaskName(oldTask, newParams, type),
                            updateReminder(oldTask, newParams, type),
                            updateTags(oldTask, newParams)
                                 ); 
            	}
                break;
            default:
                assert false : "Invalid class type";
            }
        } catch (IllegalValueException ive) {
            assert false : "There should not be any illegal value at this point";
        }
        
        return newActivity;
    }

    public static void marksTask(Activity task, boolean isComplete) {
		task.setCompletionStatus(isComplete);
	}

```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
	private static Name updateTaskName(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        Name newTaskName;

        if (newParams.getName().toString().equals(NULL_ENTRY)&& type.equals("edit")) {
            newTaskName = new Name(oldTask.getName().toString());
        } else {
            newTaskName = new Name(newParams.getName().toString());
        }

        return newTaskName;
    }

```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
    private static DueDate updateDueDate(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        DueDate newDueDate;
        
        if (!newParams.getClass().getSimpleName().equalsIgnoreCase("task")) {
            return new DueDate(((Task) oldTask).getDueDate().getCalendarValue());
        }

        if (((Task) newParams).getDueDate().toString().equals(NULL_ENTRY)&& type.equals("edit")) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase("activity")) {
                newDueDate = new DueDate("");
            } else {
                newDueDate = new DueDate(((Task) oldTask).getDueDate().getCalendarValue());
            }
        } else {
            newDueDate = new DueDate(((Task) newParams).getDueDate().getCalendarValue());
        }

        return newDueDate;
    }

```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
    private static Priority updatePriority(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        Priority newPriority;
        
        if (!newParams.getClass().getSimpleName().equalsIgnoreCase("task")) {
            return new Priority(((Task) oldTask).getPriority().toString());
        }

        if (((Task) newParams).getPriority().toString().equals(NULL_ENTRY)&& type.equals("edit")) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase("activity")) {
                newPriority = new Priority("0");
            } else {
                newPriority = new Priority(((Task) oldTask).getPriority().toString());
            }
        } else {
            newPriority = new Priority(((Task) newParams).getPriority().toString());
        }

        return newPriority;
    }

```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
    private static Reminder updateReminder(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        Reminder newReminder;

        if (newParams.getReminder().toString().equals(NULL_ENTRY)&& type.equals("edit")) {
            newReminder = new Reminder(oldTask.getReminder().getCalendarValue());
            newReminder.recurring=oldTask.getReminder().recurring;
            newReminder.RecurringMessage = oldTask.getReminder().RecurringMessage;            
        } else {
            newReminder = new Reminder(newParams.getReminder().getCalendarValue());
            newReminder.recurring=newParams.getReminder().recurring;
            newReminder.RecurringMessage = newParams.getReminder().RecurringMessage;
        }

        return newReminder;
    }
    
    //Handle wrong time format in event instead of here?
```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
    private static StartTime updateStartTime(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        StartTime newStartTime;
        
        if (!newParams.getClass().getSimpleName().equalsIgnoreCase("event")) {
            return new StartTime(((Event) oldTask).getStartTime().getCalendarValue());
        }

        if (((Event) newParams).getStartTime().toString().equals(NULL_ENTRY)&& type.equals("edit")) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase("activity")) {
                newStartTime = new StartTime("");
            } else {
                newStartTime = new StartTime(((Event) oldTask).getStartTime().getCalendarValue());
                newStartTime.recurring = ((Event) oldTask).getStartTime().recurring;
                newStartTime.RecurringMessage = ((Event) oldTask).getStartTime().RecurringMessage;

            }
        } else {
            newStartTime = new StartTime(((Event) newParams).getStartTime().getCalendarValue());
            newStartTime.recurring = ((Event) newParams).getStartTime().recurring;
            newStartTime.RecurringMessage = ((Event) newParams).getStartTime().RecurringMessage;
        }

        return newStartTime;
    }

```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
    private static EndTime updateEndTime(Activity oldTask, Activity newParams, String type) throws IllegalValueException {
        EndTime newEndTime;
        
        if (!newParams.getClass().getSimpleName().equalsIgnoreCase("event")) {
            return new EndTime(((Event) oldTask).getEndTime().getCalendarValue());
        }

        if (((Event) newParams).getEndTime().toString().equals(NULL_ENTRY)&& type.equals("edit")) {
            if (oldTask.getClass().getSimpleName().equalsIgnoreCase("activity")) {
                newEndTime = new EndTime(((Event) oldTask).getStartTime(), ""); //what to put as starttime?
            } else {
                newEndTime = new EndTime(((Event) oldTask).getEndTime().getCalendarValue());
                newEndTime.recurring = ((Event) oldTask).getEndTime().recurring;
                newEndTime.RecurringMessage = ((Event) oldTask).getEndTime().RecurringMessage;
            }
        } else {
            newEndTime = new EndTime(((Event) newParams).getEndTime().getCalendarValue());
            newEndTime.recurring = ((Event) newParams).getEndTime().recurring;
            newEndTime.RecurringMessage = ((Event) newParams).getEndTime().RecurringMessage;
        }

        return newEndTime;
    }
   
```
###### \java\seedu\address\model\activity\ActivityManager.java
``` java
    private static UniqueTagList updateTags(Activity oldTask, Activity newParams) {
        UniqueTagList newTags = new UniqueTagList(oldTask.getTags());

        for (Tag toAdd : newParams.getTags()) {
            try {
                newTags.add(toAdd);
            } catch (DuplicateTagException e) {
                continue;
            }
        }

        return newTags;
    }



}
```
###### \java\seedu\address\model\activity\DateTime.java
``` java
public abstract class DateTime implements Comparable<DateTime>{
    public Calendar value;
    protected static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("EEE, MMM d, yyyy h:mm a");
    protected static final SimpleDateFormat SAVE_DATE_FORMAT = new SimpleDateFormat("d-MM-yyyy h:mm aa");
    protected static final DateUtil DATE_PARSER = new DateUtil();
    public boolean recurring;

    public DateTime(Calendar date) {
        if (date == null) {
            this.value = null;
        } else {
            this.value = Calendar.getInstance();
            this.value.setTime(date.getTime());
        }
    }

    public DateTime(String date) throws IllegalValueException {
        assert date != null;

        if (date.equals("")) {
            this.value = null;
        } else {
            this.value = Calendar.getInstance();
            this.value.set(Calendar.MILLISECOND, 0);
            this.value.set(Calendar.SECOND, 0);
        }
    }
    
```
###### \java\seedu\address\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is before the current time.
     */
    public boolean isBeforeNow() {
        Date now = Calendar.getInstance().getTime();
        return this.value.getTime().before(now);
    }
    
```
###### \java\seedu\address\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is after the current time.
     */
    public boolean isAfterNow() {
        Date now = Calendar.getInstance().getTime();
        return this.value.getTime().after(now);
    }
    
```
###### \java\seedu\address\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is before the date in the specified DateTime object.
     */
    public boolean isBefore(DateTime other) {
        Date otherDate = other.getCalendarValue().getTime();
        return this.value.getTime().before(otherDate);
    }
    
```
###### \java\seedu\address\model\activity\DateTime.java
``` java
    /**
     * Returns true if the stored time is after the date in the specified DateTime object.
     */
    public boolean isAfter(DateTime other) {
        Date otherDate = Calendar.getInstance().getTime();
        return this.value.getTime().after(otherDate);
    }
    
    /**
     * Comparator for DateTime. Earlier dates are ordered before later dates.
     */
    @Override
    public int compareTo(DateTime other) {
        return this.value.getTime().compareTo(other.value.getTime());
    }

    /**
     * Returns true if a given string is a valid task reminder.
     */
    protected static boolean isValidDate(String test) {
        if (DATE_PARSER.validate(test) || test.equals("") ||test.contains("today") || test.contains("tomorrow")||test.contains("mon")||test.contains("tue")||test.contains("wed")||test.contains("thu")||test.contains("fri")||test.contains("sat")||test.contains("sun"))
            return true;
        else
            return false;
    }

    public Calendar getCalendarValue() {
        return this.value;
    }
    
    public abstract String forDisplay();

    @Override
    public String toString() {
        if (this.value == null) {
            return "";
        } else {
            return DATE_FORMAT.format(value.getTime());
        }
    }


    public String toSave() {
        if (this.value == null) {
            return new String("");
        } else {
            return SAVE_DATE_FORMAT.format(value.getTime());
        }
    }
    
    @Override
    public boolean equals(Object other) {
        if (value == null || ((DateTime) other).value == null) {
            return !((value == null) ^ ((DateTime) other).value == null);
        } else {
            return other == this // short circuit if same object
                    || (other instanceof DateTime // instanceof handles nulls
                            && this.value.equals(((DateTime) other).value)); // state
                                                                             // check
        }
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### \java\seedu\address\model\activity\event\ReadOnlyEvent.java
``` java
public interface ReadOnlyEvent extends ReadOnlyActivity {
    StartTime getStartTime();
    EndTime getEndTime();
    
    boolean isOngoing();
    boolean isOver();

    String toStringCompletionStatus();
    
    String displayTiming();
    
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyEvent other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getStartTime().equals(this.getStartTime())
                && other.getEndTime().equals(this.getEndTime())
                && other.getReminder().equals(this.getReminder()));
    }
    
    /**
     * Formats the activity as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
                .append(" Start Time: ")
                .append(getStartTime())
                .append(" End Time: ")
                .append(getEndTime())
                .append(" Reminder: ")
                .append(getReminder())
                .append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

}
```
###### \java\seedu\address\model\activity\task\Priority.java
``` java
import seedu.lifekeeper.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's priority value in the Lifekeeper.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS =
            "Task priority should be an integer between 0 and 3 inclusive.";
    public static final String PRIORITY_VALIDATION_REGEX = "[0-3]";

    public final String value;

    /**
     * Validates given priority value.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        priority = priority.trim();
        if (!isValidPriority(priority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        this.value = priority;
    }

    /**
     * Returns if a given string is a valid activity email.
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX) || test.equals("");
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
    
    public String forDisplay() {
        switch (value) {
        case "1":
            return "Priority:\t\tLow";
        case "2":
            return "Priority:\t\tMedium";
        case "3":
            return "Priority:\t\tHigh";
        default:
            return "Priority:\t\tNone";
        }
    }
    
    public String forReminderDialog() {
        switch (value) {
        case "1":
            return "Low";
        case "2":
            return "Medium";
        case "3":
            return "High";
        default:
            return "-";
        }
    }
    
    public Image getPriorityIcon() {
        switch (value) {
        case "1":
            return new Image(getClass().getResourceAsStream("/images/priority1.png"));
        case "2":
            return new Image(getClass().getResourceAsStream("/images/priority2.png"));
        case "3":
            return new Image(getClass().getResourceAsStream("/images/priority3.png"));
        default:
            return null;
        }
    }
}
```
###### \java\seedu\address\model\activity\task\ReadOnlyTask.java
``` java
public interface ReadOnlyTask extends ReadOnlyActivity {

    DueDate getDueDate();
    Priority getPriority();
    boolean getCompletionStatus();
    boolean isDueDateApproaching();
    boolean hasPassedDueDate();
    
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getDueDate().equals(this.getDueDate())
                && other.getPriority().equals(this.getPriority())
                && other.getReminder().equals(this.getReminder()));
    }
    
    /**
     * Formats the activity as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
                .append(" Duedate: ")
                .append(getDueDate())
                .append(" Priority: ")
                .append(getPriority())
                .append(" Reminder: ")
                .append(getReminder())
                .append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

    String toStringCompletionStatus();
}
```
###### \java\seedu\address\model\activity\UniqueActivityList.java
``` java
    /**
     * Edits the equivalent Task from the list.
     *
     * @throws TaskNotFoundException if no such activity could be found in the list.
     */
    public void edit(Activity task, Activity newTask) throws TaskNotFoundException, DuplicateTaskException {
        assert task != null;
        assert newTask != null;
        
        if (contains(newTask)) {
            throw new DuplicateTaskException();
        }
        
        int index = internalList.indexOf(task);
        if(index == -1) {
            throw new TaskNotFoundException();
        }

        internalList.set(index, newTask);
    }
    
```
###### \java\seedu\address\model\activity\UniqueActivityList.java
``` java
    public void mark(Activity task, boolean isComplete) throws TaskNotFoundException {
        int index = internalList.indexOf(task);
        
        if (index == -1) {
            throw new TaskNotFoundException();
        }
        
        ActivityManager.marksTask(task, isComplete);
        
        internalList.set(index, task);
    }
    
    public ObservableList<Activity> getInternalList() {
        return internalList;
    }

    /**
     * Returns task if the list contains an equivalent task as the given argument.
     */
    public Activity get(Activity toGet) {
        assert toGet != null;
        return internalList.get(internalList.indexOf(toGet));
    }

    @Override
    public Iterator<Activity> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueActivityList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueActivityList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }


}
```
###### \java\seedu\address\model\activity\UpcomingReminders.java
``` java
/**
 * Keeps a queue of upcoming events. Events that are ongoing or over will not be
 * added to the queue.
 */
public class UpcomingReminders {

    private static final int DEFAULT_SIZE = 50;

    private static PriorityQueue<ReadOnlyActivity> reminderQueue;

    {
        reminderQueue = new PriorityQueue<>(DEFAULT_SIZE, new Comparator<ReadOnlyActivity>() {
            public int compare(ReadOnlyActivity first, ReadOnlyActivity second) {
                return first.getReminder().compareTo(second.getReminder());
            }
        });
    }

    public UpcomingReminders() {
    }

    public UpcomingReminders(Collection<ReadOnlyActivity> activities) {
        for (ReadOnlyActivity activity : activities) {
            if (activity.getReminder().getCalendarValue() != null && !activity.hasReminderPassed()) {
                reminderQueue.add(activity);
            }
        }
    }

    public void initialize(Collection<Activity> activities) {
        for (ReadOnlyActivity activity : activities) {
            if (activity.getReminder().getCalendarValue() != null && !activity.hasReminderPassed()) {
                reminderQueue.add(activity);
            }
        }
    }

    /**
     * Adds an activity to the reminder queue. Activities without reminder or a
     * passed reminder will not be added.
     * 
     * @return true if the activity is added to the queue.
     */
    public boolean addReminder(ReadOnlyActivity newActivity) {
        if (newActivity.getReminder().getCalendarValue() != null && !newActivity.hasReminderPassed()) {
            return reminderQueue.add(newActivity);
        } else {
            return false;
        }
    }

    /**
     * Removes the activity from the reminder queue, if it exists.
     * 
     * @return true if the reminder is successfully removed.
     */
    public boolean removeReminder(ReadOnlyActivity activity) {
        return reminderQueue.remove(activity);
    }

    /**
     * Returns a list of events that is upcoming.
     * 
     * @return a list of the events with start time closest to current time.
     */
    public static ArrayList<ReadOnlyActivity> popNextReminders() {
        ArrayList<ReadOnlyActivity> nextRemindedActivities = new ArrayList<>();

        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.SECOND, 10);
        Date offset10Secs = cal.getTime();

        while (!reminderQueue.isEmpty()
                && reminderQueue.peek().getReminder().getCalendarValue().getTime().before(offset10Secs)) {
            ReadOnlyActivity toBeReminded = reminderQueue.poll();
            nextRemindedActivities.add(toBeReminded);
            toBeReminded.getReminder().resetTime();
        }
        
        return nextRemindedActivities;
    }
}
```
###### \java\seedu\address\model\AddressBook.java
``` java
    public Activity editTask(Activity task, Activity newParams, String type) throws TaskNotFoundException, DuplicateTaskException {
            if (activities.contains(task)) {
                Activity newTask = ActivityManager.editUnaffectedParams(task, newParams, type);
                activities.edit(task, newTask);
                nextReminders.removeReminder(task);
                nextReminders.addReminder(newTask);
                
                return newTask;
            } else {
                throw new UniqueActivityList.TaskNotFoundException();
            }
    }

	public void markTask(Activity task, boolean isComplete) throws TaskNotFoundException {
        if (activities.contains(task)) {
            activities.mark(task, isComplete);
        } else {
            throw new UniqueActivityList.TaskNotFoundException();
        }
	}
    
//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return activities.getInternalList().size() + " persons, " + tags.getInternalList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyActivity> getPersonList() {
        return Collections.unmodifiableList(activities.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueActivityList getUniquePersonList() {
        return this.activities;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddressBook // instanceof handles nulls
                && this.activities.equals(((AddressBook) other).activities)
                && this.tags.equals(((AddressBook) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(activities, tags);
    }



}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized Activity editTask(Activity oldTask, Activity newParams) throws TaskNotFoundException, DuplicateTaskException {
        Activity editedTask = lifeKeeper.editTask(oldTask, newParams, "edit");
        indicateAddressBookChanged();
        
        return editedTask;
    }
    
    @Override
    public synchronized Activity undoEditTask(Activity oldTask, Activity newParams) throws TaskNotFoundException, DuplicateTaskException {
        Activity editedTask = lifeKeeper.editTask(oldTask, newParams, "undo");
        indicateAddressBookChanged();
        
        return editedTask;
    }

	@Override
	public synchronized void markTask(Activity taskToMark, boolean isComplete) throws TaskNotFoundException {
		lifeKeeper.markTask(taskToMark, isComplete);
        updateFilteredListToShowAll();
        indicateAddressBookChanged();
		
	}
    
    //=========== Filtered Person List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyActivity> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredPersons);
    }
    
    @Override
    public UnmodifiableObservableList<Activity> getFilteredTaskListForEditing() {
        return new UnmodifiableObservableList<>(filteredPersons);
    }
```
###### \java\seedu\address\storage\XmlAddressBookStorage.java
``` java
    /**
     * Sets the storage location of the activity data to the new file path specified
     * @param filePath
     */
    public static void setAddressBookFilePath(String filePath){
        XmlAddressBookStorage.filePath = filePath;
    }

    public String getAddressBookFilePath(){
        return filePath;
    }

    /**
     * Similar to {@link #readAddressBook()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyLifeKeeper> readAddressBook(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File addressBookFile = new File(filePath);

        if (!addressBookFile.exists()) {
            logger.info("AddressBook file "  + addressBookFile + " not found");
            return Optional.empty();
        }

        ReadOnlyLifeKeeper addressBookOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(addressBookOptional);
    }

    /**
     * Similar to {@link #saveAddressBook(ReadOnlyLifeKeeper)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveAddressBook(ReadOnlyLifeKeeper lifeKeeper, String filePath) throws IOException {
        assert lifeKeeper != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableAddressBook(lifeKeeper));
    }

    @Override
    public Optional<ReadOnlyLifeKeeper> readAddressBook() throws DataConversionException, IOException {
        return readAddressBook(filePath);
    }

    @Override
    public void saveAddressBook(ReadOnlyLifeKeeper lifeKeeper) throws IOException {
        saveAddressBook(lifeKeeper, filePath);
    }
    
    public static boolean checkIfDataFileExists(String filePath) {
        File file = new File(filePath);
        return file.exists();
    }
}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    @FXML
    private void handleSaveLoc() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setCurrentDirectory(new File("data/addressbook.xml"));
        fileChooser.setFileFilter(new FileNameExtensionFilter("XML File", "xml"));
        fileChooser.setAcceptAllFileFilterUsed(false);
        int result = fileChooser.showSaveDialog(null);
        
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            
            if (!selectedFile.getAbsolutePath().endsWith(".xml")) {
                selectedFile = new File(selectedFile.getAbsolutePath() + ".xml");
            }
            
            XmlAddressBookStorage.setAddressBookFilePath(selectedFile.getAbsolutePath());
            resultDisplay.postMessage("New save location: " + selectedFile.getAbsolutePath());
            
            userPrefs.setDataFilePath(selectedFile.getAbsolutePath());
            statusBarFooter.setSaveLocation(selectedFile.getAbsolutePath());
        }
    }

    public ActivityListPanel getActivityListPanel() {
        return this.activityListPanel;
    }

    public void refresh() {
        activityListPanel.refresh();
        
    }

}
```
###### \java\seedu\address\ui\UiManager.java
``` java
    private void showReminderDialog(ArrayList<ReadOnlyActivity> activities) {
        ImageIcon reminderIcon = new ImageIcon(getClass().getResource("/images/ringing.png"),
                "Reminder Bell");
        
        for (ReadOnlyActivity activity : activities) {
            JOptionPane.showMessageDialog(new JFrame(),
                    textForReminderDialog(activity, activity.getClass().getSimpleName()),
                    "Reminder: " + activity.getName().toString(),
                    JOptionPane.INFORMATION_MESSAGE,
                    reminderIcon);
        }
    }
    
```
###### \java\seedu\address\ui\UiManager.java
``` java
    private String textForReminderDialog(ReadOnlyActivity activity, String type) {
        final StringBuilder sb = new StringBuilder();
        
        sb.append("Reminder for the " + type.toLowerCase() + ": " +  activity.getName());
        
        switch (type) {
        case "Task":
            if (((Task) activity).getDueDate().getCalendarValue() != null) {
                sb.append("\nDue:       " + ((Task) activity).getDueDate().toString());
            }
            sb.append("\nPriority: " + ((Task) activity).getPriority().forReminderDialog());
            break;
        case "Event":
            sb.append("\nTime: " + ((Event) activity).getStartTime().toString()
                    + "\nto        " + ((Event) activity).getEndTime().toString());
            break;
        }
        
        return sb.toString();
    }

    //==================== Event Handling Code =================================================================

    @Subscribe
    private void handleDataSavingExceptionEvent(DataSavingExceptionEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showFileOperationAlertAndWait("Could not save data", "Could not save data to file", event.exception);
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getActivityListPanel().scrollTo(event.targetIndex);
    }

    @Subscribe
    private void handlePersonPanelSelectionChangedEvent(PersonPanelSelectionChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
    }
    
    //==================== Refresh Handling Code =================================================================
    
```
###### \java\seedu\address\ui\UiManager.java
``` java
    /**
     * Methods to invoke refreshing every minute
     */
    private void initRefresh() {
        refreshTimer.cancel();
        reminderTimer.cancel();
        refreshTimer = new Timer("Refresh");
        reminderTimer = new Timer("Reminder");
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        Date executionDate = cal.getTime();
        cal.add(Calendar.SECOND, 1);
        refreshTimer.scheduleAtFixedRate(refreshTask, executionDate, DELAY);
        reminderTimer.scheduleAtFixedRate(reminderTask, cal.getTime(), DELAY);
    }
    
    private class RefreshTask extends TimerTask {
        public void run() {
            mainWindow.refresh();
        }
    }

    private class ReminderTask extends TimerTask {
        public void run() {
            showReminderDialog(UpcomingReminders.popNextReminders());
        }
    }
}
```
###### \resources\view\MainWindow.fxml
``` fxml
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleSaveLoc" text="Set Save Path..." />
               </items>
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="activityListPanelPlaceholder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
            <VBox fx:id="dashboardDisplay" minWidth="200.0" prefWidth="200.0">
               <children>
                  <VBox fx:id="overdueTaskList" prefHeight="200.0" prefWidth="200.0">
                     <children>
                        <AnchorPane fx:id="overdueTaskDisplayPlaceHolder" />
                     </children>
                  </VBox>
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
